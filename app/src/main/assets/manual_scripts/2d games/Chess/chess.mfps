#This is a chess game. It is not a computer against man game.
#Instead, there must be two players to attend. The two players are
#using two physical devices which communicate with each other using
#TCPIP or WEBRTC protocol.
#这是一个国际象棋的游戏。需要注意的是它并非是一个人和计算机对阵的游戏。它只支持
#人对人的模式。和其他的游戏不同的是，游戏双方使用的是两个不同的设备，通过TCPIP
#或者WEBRTC协议进行通讯。

@execution_entry gdi_test::game_test::chess::main

citingspace gdi_test::game_test::chess

function getNumOfPieces()
	return 16
endf

function getTextColor()
	return [180, 180, 0]
endf

function getTextFontSize()
	return 30
endf

class CCheckerBoard
	variable self allMyPieces, allOtherPieces
	variable self color
	variable self selectedIdx
	public function initPiecePair(self, color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
		if color == false // black
			self.allMyPieces[idx] = myPiece.__init__(color, CCheckerBoardCoord().__init__(posX,blackPosY), self, idx)
			self.allOtherPieces[idx] = otherPiece.__init__(!color, CCheckerBoardCoord().__init__(posX,whitePosY), self, idx)
		else
			self.allMyPieces[idx] = myPiece.__init__(color, CCheckerBoardCoord().__init__(posX,whitePosY), self, idx)
			self.allOtherPieces[idx] = otherPiece.__init__(!color, CCheckerBoardCoord().__init__(posX,blackPosY), self, idx)
		endif
	endf
	public function isInitialized(self)
		return self.allMyPieces != null
	endf
	public function __init__(self, color)
		self.allMyPieces = alloc_array([getNumOfPieces()], null)
		self.allOtherPieces = alloc_array([getNumOfPieces()], null)
		variable idx = 0
		variable posX, blackPosY, whitePosY, myPiece, otherPiece
		posX = "a"
		blackPosY = "8"
		whitePosY = "1"
		myPiece = Rook()
		otherPiece = Rook()
		self.initPiecePair(color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
		idx = idx + 1
		
		posX = "b"
		blackPosY = "8"
		whitePosY = "1"
		myPiece = Knight()
		otherPiece = Knight()
		self.initPiecePair(color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
		idx = idx + 1
		
		posX = "c"
		blackPosY = "8"
		whitePosY = "1"
		myPiece = Bishop()
		otherPiece = Bishop()
		self.initPiecePair(color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
		idx = idx + 1

		posX = "d"
		blackPosY = "8"
		whitePosY = "1"
		myPiece = Queen()
		otherPiece = Queen()
		self.initPiecePair(color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
		idx = idx + 1

		posX = "e"
		blackPosY = "8"
		whitePosY = "1"
		myPiece = King()
		otherPiece = King()
		self.initPiecePair(color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
		idx = idx + 1

		posX = "f"
		blackPosY = "8"
		whitePosY = "1"
		myPiece = Bishop()
		otherPiece = Bishop()
		self.initPiecePair(color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
		idx = idx + 1

		posX = "g"
		blackPosY = "8"
		whitePosY = "1"
		myPiece = Knight()
		otherPiece = Knight()
		self.initPiecePair(color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
		idx = idx + 1

		posX = "h"
		blackPosY = "8"
		whitePosY = "1"
		myPiece = Rook()
		otherPiece = Rook()
		self.initPiecePair(color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
		idx = idx + 1

		variable posXs = ["a","b","c","d","e","f","g","h"]
		for variable pawnIdx = 1 to 8 step 1
			posX = posXs[pawnIdx - 1]
			blackPosY = "7"
			whitePosY = "2"
			myPiece = Pawn()
			otherPiece = Pawn()
			self.initPiecePair(color, idx, posX, blackPosY, whitePosY, myPiece, otherPiece)
			idx = idx + 1
		next
		
		self.color = color
		self.selectedIdx = -1
		return self
	endf
	
	public function eatPiece(self, idxMine, idxOthers) // eat the other player's piece. // 吃掉对方的一个子.
		if self.allMyPieces[idxMine] == null
			return null
		elseif self.allOtherPieces[idxOthers] == null
			return ""
		else
			variable pieceName = self.allOtherPieces[idxOthers].name
			self.allOtherPieces[idxOthers] = null
			return pieceName
		endif
	endf
	
	public function updatePieces(self, updateMsg)	// update the checkerboard //更新棋盘
		variable remoteIdx = updateMsg[0]
		if or(remoteIdx < 0, remoteIdx >= getNumOfPieces(), self.allOtherPieces[remoteIdx] == null)
			return null // invalid remote idx //不合法的remoteIdx
		else 
			if and(self.allOtherPieces[remoteIdx].name == "Pawn", or(and(self.color, updateMsg[2] == 0), and(!self.color, updateMsg[2] == 7)))
				// Pawn upgrade to Queen // 卒子变成后
				self.allOtherPieces[remoteIdx] = Queen().__init__(self.allOtherPieces[remoteIdx].color, CCheckerBoardCoord().__init__(updateMsg[1], updateMsg[2]), self.allOtherPieces[remoteIdx].checkerBoard, remoteIdx)
				self.allOtherPieces[remoteIdx].status = 1
			else
				if updateMsg[3] == "Castling"
					if updateMsg[1] < self.allOtherPieces[remoteIdx].coord.getX()	// move to queen's side //向后的方向移动
						self.allOtherPieces[0].coord.setXY(updateMsg[1] + 1, updateMsg[2])
					else // move away from queen's side //向远离后的方向移动
						self.allOtherPieces[7].coord.setXY(updateMsg[1] - 1, updateMsg[2])
					endif
				endif
				self.allOtherPieces[remoteIdx].coord.setXY(updateMsg[1], updateMsg[2])
			endif
			variable coordFromMyView = self.allOtherPieces[remoteIdx].getOppositeCoord()
			for variable idx = 0 to getNumOfPieces() - 1 step 1
				if and(self.allMyPieces[idx] != null, self.allMyPieces[idx].coord == coordFromMyView)
					variable eatenPiece = self.allMyPieces[idx]
					self.allMyPieces[idx] = null
					return eatenPiece
				endif
			next
		endif
		return null	// no piece was eaten // 没有棋子被吃掉
	endf

	public function draw(self, DISPLAYSURF, allImages, rtcMmediaMgr, boardLeft, boardTop, boardScaledW, boardScaledH, scalingRatio, message)
		drop_old_painting_requests("chess", DISPLAYSURF)
		draw_image("chess", DISPLAYSURF, get_value_from_abdict(allImages, "ChessCheckerBoard"), boardLeft, boardTop, scalingRatio, scalingRatio)
		
		variable textOrigin, thisChars, stepIdx = 0
		if self.color
			thisChars = ["A", "B", "C", "D", "E", "F", "G", "H"]
		else
			thisChars = ["H", "G", "F", "E", "D", "C", "B", "A"]
		endif
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.9433685 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.9433685 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.9433685 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.9433685 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.9433685 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.9433685 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.9433685 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.9433685 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		if self.color
			thisChars = ["8", "7", "6", "5", "4", "3", "2", "1"]
		else
			thisChars = ["1", "2", "3", "4", "5", "6", "7", "8"]
		endif
		stepIdx = 0
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.026115023 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.95246479 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.026115023 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.95246479 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.026115023 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.95246479 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.026115023 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.95246479 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.026115023 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.95246479 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.026115023 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.95246479 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.026115023 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.95246479 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1
		
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.026115023 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + 0.95246479 * boardScaledW, boardTop + (0.1071009 + stepIdx * 0.1078345) * boardScaledH], 0.021420188 * boardScaledW, 0.03726526 * boardScaledH, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
		stepIdx = stepIdx + 1	
		
		if message != null 
			variable textOrigin = calculate_text_origin(DISPLAYSURF, message, [boardLeft + 0.0067488263 * boardScaledW, boardTop + 0.0070422535 * boardScaledH], boardScaledW * 0.98591549, boardScaledH * 0.0595657277, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, message, textOrigin, getTextColor(), getTextFontSize())
		else
			if self.color
				thisChars = ["A", "B", "C", "D", "E", "F", "G", "H"]
			else
				thisChars = ["H", "G", "F", "E", "D", "C", "B", "A"]
			endif
			stepIdx = 0
			textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.01936620 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
			stepIdx = stepIdx + 1
			
			textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.01936620 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
			stepIdx = stepIdx + 1
			
			textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.01936620 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
			stepIdx = stepIdx + 1
			
			textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.01936620 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
			stepIdx = stepIdx + 1
			
			textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.01936620 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
			stepIdx = stepIdx + 1
			
			textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.01936620 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
			stepIdx = stepIdx + 1
			
			textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.01936620 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
			stepIdx = stepIdx + 1
			
			textOrigin = calculate_text_origin(DISPLAYSURF, thisChars[stepIdx], [boardLeft + (0.10357981 + stepIdx * 0.1078345) * boardScaledW, boardTop + 0.01936620 * boardScaledH], 0.03902582 * boardScaledW, 0.03667840 * boardScaledH, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, thisChars[stepIdx], textOrigin, getTextColor(), getTextFontSize())
			stepIdx = stepIdx + 1			
		endif
		for variable idx = 0 to getNumOfPieces() - 1 step 1
			if self.allMyPieces[idx] != null
				variable pieceLT = getLeftTopPiece(self.color, boardLeft, boardTop, boardScaledW, boardScaledH, self.allMyPieces[idx].coord.getX(), self.allMyPieces[idx].coord.getY())
				variable color = "B"
				if self.allMyPieces[idx].color == True
					color = "W"
				endif
				draw_image("chess", DISPLAYSURF, get_value_from_abdict(allImages, color + self.allMyPieces[idx].name), pieceLT[0], pieceLT[1], scalingRatio, scalingRatio)
				if self.selectedIdx == idx
					draw_image("chess", DISPLAYSURF, get_value_from_abdict(allImages, "SelectedChessPiece"), pieceLT[0], pieceLT[1], scalingRatio, scalingRatio)
				endif
			endif
			
			if self.allOtherPieces[idx] != null
				variable pieceLT = getLeftTopPiece(self.color, boardLeft, boardTop, boardScaledW, boardScaledH, self.allOtherPieces[idx].getOppositeCoord().getX(), self.allOtherPieces[idx].getOppositeCoord().getY())
				variable color = "B"
				if self.allOtherPieces[idx].color == True
					color = "W"
				endif
				draw_image("chess", DISPLAYSURF, get_value_from_abdict(allImages, color + self.allOtherPieces[idx].name), pieceLT[0], pieceLT[1], scalingRatio, scalingRatio)
			endif
		next
		if rtcMmediaMgr != null
			rtcMmediaMgr.drawCtrlButtons(allImages)
		endif
		update_display(DISPLAYSURF)
	endf
	
	public function findSelectedPiece(self, xy)
		for variable idx = 0 to getNumOfPieces() - 1 step 1
			if and(self.allMyPieces[idx] != null, self.allMyPieces[idx].coord.getXY() == xy)
				self.selectedIdx = idx	// if select my own piece, update selectedIdx //如果选中了自己的棋子，就需要更新selectedIdx
				return self.allMyPieces[idx]
			endif
			
			if and(self.allOtherPieces[idx] != null, self.allOtherPieces[idx].getOppositeCoord().getXY() == xy)
				return self.allOtherPieces[idx]
			endif
		next
		return null
	endf
endclass

class CCheckerBoardCoord
	private variable self x, y	// x, y coordinate. Note that whether black or white, x is always in [0, 7] while y is always in [0, 7]
	public function __init__(self, x, y)
		select x
		case "a"
			self.x = 0
			break
		case "b"
			self.x = 1
			break
		case "c"
			self.x = 2
			break
		case "d"
			self.x = 3
			break
		case "e"
			self.x = 4
			break
		case "f"
			self.x = 5
			break
		case "g"
			self.x = 6
			break
		case "h"
			self.x = 7
			break
		default
			variable xCord = round(x)
			if and(xCord >= 0, xCord <= 7)
				self.x = xCord
			else
				throw "Invalid X Index: " + xCord
			endif
		ends
		select y
		case "1"
			self.y = 0
			break
		case "2"
			self.y = 1
			break
		case "3"
			self.y = 2
			break
		case "4"
			self.y = 3
			break
		case "5"
			self.y = 4
			break
		case "6"
			self.y = 5
			break
		case "7"
			self.y = 6
			break
		case "8"
			self.y = 7
			break
		default
			variable yCord = round(y)
			if and(yCord >= 0, yCord <= 7)
				self.y = yCord
			else
				throw "Invalid Y Index： " + yCord
			endif
		ends
		return self
	endf
	
	public function __init__(self, xy)
		return self.__init__(xy[0], xy[1])
	endf

	public function getX(self)
		return self.x
	endf
	public function getY(self)
		return self.y
	endf
	public function getXY(self)
		return [self.x, self.y]
	endf
	public function setX(self, newX)
		if or(newX < 0, newX > 7)
			return False
		else
			self.x = newX
			return True
		endif
	endf
	public function setY(self, newY)
		if or(newY < 0, newY > 7)
			return False
		else
			self.y = newY
			return True
		endif
	endf
	public function setXY(self, newXY)
		if or(newXY[0] < 0, newXY[0] > 7, newXY[1] < 0, newXY[1] > 7)
			return False
		else
			self.x = newXY[0]
			self.y = newXY[1]
			return True
		endif
	endf
	public function setXY(self, newX, newY)
		return self.setXY([newX, newY])
	endf
	public function getOppositeX(self)
		return self.x
	endf
	public function getOppositeY(self)
		return self.y
	endf
	public function getOppositeXY(self)
		return [self.x, self.y]
	endf
	public function getOppositeCoord(self)
		variable oppositeCoord = CCheckerBoardCoord()
		oppositeCoord.setXY(self.x, self.y)	// this statement will not fail
		return oppositeCoord
	endf
	
	public function __equals__(self, o)
		if self.__is_same__(o) // identify if self and o refer to the same object.
			return true
		elseif null == o
			return false
		elseif get_type_fullname(self) != get_type_fullname(o)
			return false
		elseif or(self.x != o.x, self.y != o.y)
			return false
		else
			return true
		endif
	endf
	
	public function equalsOppositeCoord(self, coord)
		if coord ==  null
			return false
		elseif get_type_fullname(self) != get_type_fullname(coord)
			return false
		elseif and(self.x == coord.x, self.y == coord.y)
			return true
		else
			return false
		endif
	endf
endclass

class Piece
	variable self checkerBoard
	variable self name
	variable self color	// black is false, white is true
	variable self coord	// coordinate of the piece
	variable self idx
	variable self status
		
	function __init__(self, color, initPos, chkrBoard, idx)
		self.checkerBoard = chkrBoard
		if color == self.checkerBoard.color
			self.checkerBoard.allMyPieces[idx] = self
		else
			self.checkerBoard.allOtherPieces[idx] = self
		endif
		self.coord = initPos
		self.color = color
		self.idx = idx
		self.status = 0
		return self
	endf

	function getOppositeCoord(self)
		return self.coord.getOppositeCoord()
	endf
	
	function move(self, newCoord)
		self.coord = newCoord
		return ""
	endf
endclass

class Pawn: Piece
	function __init__(self, color, initPos, chkrBoard, idx)
		self.super[0].__init__(color, initPos, chkrBoard, idx)
		self.name = "Pawn"
		return self
	endf

	function move(self, newCoord)
		for variable idx = 0 to getNumOfPieces() - 1 step 1
			if and(self.checkerBoard.allMyPieces[idx] != null, newCoord == self.checkerBoard.allMyPieces[idx].coord)
				// newCoord is another same compaign piece's coord // newCoord 在同一阵营另外一个棋子的位置。
				return null
			endif
		next
		variable moveResult = null
		variable move2EatIdx = -1
		for variable idx = 0 to getNumOfPieces() - 1 step 1
			if and(self.checkerBoard.allOtherPieces[idx] != null, newCoord.equalsOppositeCoord(self.checkerBoard.allOtherPieces[idx].coord))
				// newCoord is an opposite compaign piece's coord // newCoord 在对立阵营另外一个棋子的位置。
				move2EatIdx = idx
				break
			endif
		next
		if move2EatIdx == -1	// This step is not to capture a piece of the opponent// 移动的目标不是吃对方一个子。
			if newCoord.getX() == self.coord.getX()	// pawn can only move straightly forward if not to capture a piece of opponent
				if self.color	// white //白方
					if newCoord.getY() - self.coord.getY() == 1
						self.status = 1
						moveResult = ""
					endif
				else	// black //黑方
					if newCoord.getY() - self.coord.getY() == -1
						self.status = 1
						moveResult = ""
					endif
				endif
				if and(moveResult == null, self.status == 0)	// Pawn hasn't been moved. //卒子还没有被移动过。
					if self.color	// white //白方
						if newCoord.getY() - self.coord.getY() == 2
							self.status = 1
							moveResult = ""
						endif
					else	// black //黑方
						if newCoord.getY() - self.coord.getY() == -2
							self.status = 1
							moveResult = ""
						endif
					endif
					variable middlePos = CCheckerBoardCoord().__init__(newCoord.getX(), (newCoord.getY() + self.coord.getY())/2)
					for variable idx = 0 to getNumOfPieces() - 1 step 1
						if and(self.checkerBoard.allMyPieces[idx] != null, middlePos == self.checkerBoard.allMyPieces[idx].coord)
							// middlePos is another same compaign piece's coord // middlePos 在同一阵营另外一个棋子的位置。
							return null
						endif
					next
					for variable idx = 0 to getNumOfPieces() - 1 step 1
						if and(self.checkerBoard.allOtherPieces[idx] != null, middlePos.equalsOppositeCoord(self.checkerBoard.allOtherPieces[idx].coord))
							// middlePos is an opposite compaign piece's coord // middlePos 在对立阵营另外一个棋子的位置。
							return null
						endif
					next
				endif
			endif
		else	// This step is to capture a piece of the opponent// 移动的目标是吃对方一个子。
			// the move could be invalid //这个移动还是有可能是非法的。
			// pawn can only move obliquely to capture a piece // 要吃对方的子，卒子只能斜着走
			if or(and(self.color, abs(newCoord.getX() - self.coord.getX()) == 1, newCoord.getY() - self.coord.getY() == 1), and(!self.color, abs(newCoord.getX() - self.coord.getX()) == 1, newCoord.getY() - self.coord.getY() == -1))
				moveResult = self.checkerBoard.eatPiece(self.idx, move2EatIdx)
				self.coord = newCoord
				self.status = 1
			endif
		endif
		if moveResult != null
			// upgrade pawn to queen (dont forget to do the same thing for the opponent) // 将卒子升级为王后（不要忘记在告诉对方）
			if or(and(self.color, newCoord.getY() == 7), and(!self.color, newCoord.getY() == 0))
				self.checkerBoard.allMyPieces[self.idx] = Queen().__init__(self.color, CCheckerBoardCoord().__init__(newCoord.getX(),newCoord.getY()), self.checkerBoard, self.idx)
				self.checkerBoard.allMyPieces[self.idx].status = 1
			else
				self.coord = newCoord
				self.status = 1
			endif
		endif
		return moveResult
	endf
endclass

class Rook: Piece
	function __init__(self, color, initPos, chkrBoard, idx)
		self.super[0].__init__(color, initPos, chkrBoard, idx)
		self.name = "Rook"
		return self
	endf

	function move(self, newCoord)
		variable moveResult = null
		if self.coord != newCoord
			variable aligned = 0
			if newCoord.getX() == self.coord.getX()
				aligned = 1	// move along Y //沿着y轴移动
			elseif newCoord.getY() == self.coord.getY()
				aligned = -1	// move along X //沿着x轴移动
			endif
			if aligned != 0
				moveResult = ""
				variable startXorY = self.coord.getX(), endXorY = newCoord.getX()
				variable newCoordXorY = newCoord.getY()
				if aligned == 1
					startXorY = self.coord.getY()
					endXorY = newCoord.getY()
					newCoordXorY = newCoord.getX()
				endif
				variable stepXorY = 1
				if endXorY < startXorY
					stepXorY = -1
				endif
				for variable idx = 0 to getNumOfPieces() -1 step 1
					variable thisPiece = self.checkerBoard.allMyPieces[idx]
					if thisPiece != null
						variable thisPieceXorY = thisPiece.coord.getY()
						variable thisPieceYorX = thisPiece.coord.getX()
						if aligned == 1
							thisPieceXorY = thisPiece.coord.getX()
							thisPieceYorX = thisPiece.coord.getY()
						endif
						if newCoordXorY == thisPieceXorY
							for variable idx1 = startXorY + stepXorY  to endXorY  step stepXorY 
								if idx1 == thisPieceYorX
									// another same compaign piece is in the path, cannot move
									// 在同一阵营另外一个棋子在移动路径上造成移动失败。
									moveResult = null
									break
								endif
							next
							if null == moveResult
								break
							endif
						endif
					endif
					thisPiece = self.checkerBoard.allOtherPieces[idx]
					if thisPiece != null
						variable thisPieceXorY = thisPiece.getOppositeCoord().getY()
						variable thisPieceYorX = thisPiece.getOppositeCoord().getX()
						if aligned == 1
							thisPieceXorY = thisPiece.getOppositeCoord().getX()
							thisPieceYorX = thisPiece.getOppositeCoord().getY()
						endif
						if newCoordXorY == thisPieceXorY
							for variable idx1 = startXorY + stepXorY to endXorY - stepXorY step stepXorY
								if idx1 == thisPieceYorX
									// another opposite compaign piece is in the path, cannot move
									// 在另外阵营另外一个棋子在移动路径上造成移动失败。
									moveResult = null
									break
								endif
							next
							if null == moveResult
								break
							endif
						endif
					endif
				next
			endif
		endif
			
		if moveResult != null
			for variable idx = 0 to getNumOfPieces() - 1 step 1
				if and(self.checkerBoard.allOtherPieces[idx] != null, newCoord.equalsOppositeCoord(self.checkerBoard.allOtherPieces[idx].coord))
					// newCoord is an opposite compaign piece's coord // newCoord 在对立阵营另外一个棋子的位置。
					moveResult = self.checkerBoard.eatPiece(self.idx, idx)
					break
				endif
			next
			self.coord = newCoord
			self.status = 1
		endif
		return moveResult
	endf
endclass

class Knight: Piece
	function __init__(self, color, initPos, chkrBoard, idx)
		self.super[0].__init__(color, initPos, chkrBoard, idx)
		self.name = "Knight"
		return self
	endf

	function move(self, newCoord)
		variable moveResult = null
		if abs((newCoord.getX() - self.coord.getX()) * (newCoord.getY() - self.coord.getY())) != 2
			return moveResult
		endif
		moveResult = ""
		for variable idx = 0 to getNumOfPieces() - 1 step 1
			variable thisPiece = self.checkerBoard.allMyPieces[idx]
			if thisPiece != null
				if and(newCoord.getX() == thisPiece.coord.getX(), newCoord.getY() == thisPiece.coord.getY())
					// another same compaign piece is in the destination, cannot move
					// 在同一阵营另外一个棋子在移动目的地上造成移动失败。
					moveResult = null
					break
				endif
				if moveResult == null
					break
				endif
			endif
		next
			
		if moveResult != null
			for variable idx = 0 to getNumOfPieces() - 1 step 1
				if and(self.checkerBoard.allOtherPieces[idx] != null, newCoord.equalsOppositeCoord(self.checkerBoard.allOtherPieces[idx].coord))
					// newCoord is an opposite compaign piece's coord // newCoord 在对立阵营另外一个棋子的位置。
					moveResult = self.checkerBoard.eatPiece(self.idx, idx)
					break
				endif
			next
			self.coord = newCoord
			self.status = 1
		endif
		return moveResult
	endf
endclass

class Bishop: Piece
	function __init__(self, color, initPos, chkrBoard, idx)
		self.super[0].__init__(color, initPos, chkrBoard, idx)
		self.name = "Bishop"
		return self
	endf

	function move(self, newCoord)
		variable moveResult = null
		if abs(newCoord.getX() - self.coord.getX()) != abs(newCoord.getY() - self.coord.getY())
			return moveResult
		else
			variable stepLength = abs(newCoord.getX() - self.coord.getX())
			moveResult = ""
			// a piece in the middle of the path may block bishop's movement.
			// 如果有一个棋子在象眼，相不能动。
			for variable idx0 = 1 to stepLength - 1
				variable middlePlace = CCheckerBoardCoord()
				variable middlePlcX = self.coord.getX() + idx0 * (newCoord.getX() - self.coord.getX())/stepLength
				variable middlePlcY = self.coord.getY() + idx0 * (newCoord.getY() - self.coord.getY())/stepLength
				middlePlace.setXY(middlePlcX, middlePlcY)
				for variable idx = 0 to getNumOfPieces() -1 step 1
					variable thisPiece = self.checkerBoard.allMyPieces[idx]
					if and(null != thisPiece, thisPiece.coord == middlePlace)
						moveResult = null
						return moveResult
					endif
					thisPiece = self.checkerBoard.allOtherPieces[idx]
					if and(null != thisPiece, thisPiece.getOppositeCoord() == middlePlace)
						moveResult = null
						return moveResult
					endif
				next
			next
			// if one of our campaign's piece in the destination it also blocks bishop's movement
			// 如果移动的终点是我方的棋子，相也不能动。
			for variable idx = 0 to getNumOfPieces() -1 step 1
				variable thisPiece = self.checkerBoard.allMyPieces[idx]
				if and(null != thisPiece, thisPiece.coord == newCoord)
					moveResult = null
					return moveResult
				endif
			next
			// it is a good move
			// 这是一个合法的移动。
			for variable idx = 0 to getNumOfPieces() - 1 step 1
				if and(self.checkerBoard.allOtherPieces[idx] != null, newCoord.equalsOppositeCoord(self.checkerBoard.allOtherPieces[idx].coord))
					// newCoord is an opposite compaign piece's coord // newCoord 在对立阵营另外一个棋子的位置。
					moveResult = self.checkerBoard.eatPiece(self.idx, idx)
					break
				endif
			next
			self.coord = newCoord
			self.status = 1
		endif
		return moveResult
	endf
endclass

class King: Piece
	function __init__(self, color, initPos, chkrBoard, idx)
		self.super[0].__init__(color, initPos, chkrBoard, idx)
		self.name = "King"
		return self
	endf

	function move(self, newCoord)
		variable moveResult = null
		if and(abs(newCoord.getX() - self.coord.getX()) <= 1, abs(newCoord.getY() - self.coord.getY()) <= 1)
			// if one of our campaign's piece in the destination it also blocks king's movement
			// 如果移动的终点是我方的棋子，将也不能动。
			// if one of opposite campaign's piece in the destination, it is eaten
			// 如果移动的终点是对方的棋子，将吃掉该棋子。
			moveResult = ""
			for variable idx = 0 to getNumOfPieces() -1 step 1
				variable thisPiece = self.checkerBoard.allMyPieces[idx]
				if and(null != thisPiece, thisPiece.coord == newCoord)
					moveResult = null
					return moveResult
				endif
				if and(self.checkerBoard.allOtherPieces[idx] != null, newCoord.equalsOppositeCoord(self.checkerBoard.allOtherPieces[idx].coord))
					// newCoord is an opposite compaign piece's coord // newCoord 在对立阵营另外一个棋子的位置。
					moveResult = self.checkerBoard.eatPiece(self.idx, idx)
					break
				endif
			next
			self.coord = newCoord
			self.status = 1
		elseif self.status == 0
			// is it castling move? // 这是王车易位吗？
			if or(and(self.color, newCoord.getY() == 0), and(!self.color, newCoord.getY() == 7))
				variable xRange0 = -1, xRange1 = -1, rookIdx = -1, rookNewCoord = CCheckerBoardCoord()
				if and(self.coord.getX() - newCoord.getX() == 2, self.checkerBoard.allMyPieces[0].status == 0)
					// king moves towards queen
					xRange0 = 0
					xRange1 = 4
					rookIdx = 0
					rookNewCoord.__init__(3, newCoord.getY())
				elseif and(newCoord.getX() - self.coord.getX() == 2, self.checkerBoard.allMyPieces[7].status == 0)
					// king moves away from queen
					xRange0 = 4
					xRange1 = 7
					rookIdx = 7
					rookNewCoord.__init__(5, newCoord.getY())
				endif
				if rookIdx >= 0
					variable noBlocking = true
					for variable idx = 0 to getNumOfPieces() - 1 step 1
						if self.checkerBoard.allMyPieces[idx] != null
							variable thisX = self.checkerBoard.allMyPieces[idx].coord.getX()
							variable thisY = self.checkerBoard.allMyPieces[idx].coord.getY()
							if and(thisX > xRange0, thisX < xRange1, thisY == newCoord.getY())
								// this is a piece blocking the castling move // 本阵营有一个棋子挡住了路
								noBlocking = false
								break
							endif
						endif
						if self.checkerBoard.allOtherPieces[idx] != null
							variable thisX = self.checkerBoard.allOtherPieces[idx].getOppositeCoord().getX()
							variable thisY = self.checkerBoard.allOtherPieces[idx].getOppositeCoord().getY()
							if and(thisX > xRange0, thisX < xRange1, thisY == newCoord.getY())
								// this is a piece blocking the castling move // 对方阵营有一个棋子挡住了路
								noBlocking = false
								break
							endif
						endif
					next
					if noBlocking
						moveResult = "Castling"
						self.coord = newCoord
						self.status = 1
						self.checkerBoard.allMyPieces[rookIdx].coord = rookNewCoord
						self.checkerBoard.allMyPieces[rookIdx].status = 1
					endif
				endif
			endif
		endif
		return moveResult
	endf
endclass

class Queen: Piece
	function __init__(self, color, initPos, chkrBoard, idx)
		self.super[0].__init__(color, initPos, chkrBoard, idx)
		self.name = "Queen"
		return self
	endf

	function move(self, newCoord)
		variable moveResult = null
		if self.coord != newCoord
			variable aligned = 0
			if newCoord.getX() == self.coord.getX()
				if newCoord.getY() > self.coord.getY()
					aligned = [0, 1]
				else // newCoord.getY() < self.coord.getY()
					aligned = [0, -1]
				endif
			elseif newCoord.getX() > self.coord.getX()
				if and(newCoord.getY() > self.coord.getY(), abs(newCoord.getX() - self.coord.getX()) == abs(newCoord.getY() - self.coord.getY()))
					aligned = [1, 1]
				elseif and(newCoord.getY() < self.coord.getY(), abs(newCoord.getX() - self.coord.getX()) == abs(newCoord.getY() - self.coord.getY()))
					aligned = [1, -1]
				elseif newCoord.getY() == self.coord.getY()
					aligned = [1, 0]
				endif
			else // newCoord.getX() < self.coord.getX()
				if and(newCoord.getY() > self.coord.getY(), abs(newCoord.getX() - self.coord.getX()) == abs(newCoord.getY() - self.coord.getY()))
					aligned = [-1, 1]
				elseif and(newCoord.getY() < self.coord.getY(), abs(newCoord.getX() - self.coord.getX()) == abs(newCoord.getY() - self.coord.getY()))
					aligned = [-1, -1]
				elseif newCoord.getY() == self.coord.getY()
					aligned = [-1, 0]
				endif
			endif
				
			if aligned != 0
				moveResult = ""
				variable steps = max(abs(newCoord.getX() - self.coord.getX()), abs(newCoord.getY() - self.coord.getY()))
				for variable idx1 = 1 to steps  step 1 
					variable middleCoord = CCheckerBoardCoord().__init__(self.coord.getXY() + aligned * idx1)
					for variable idx = 0 to getNumOfPieces() -1 step 1
						variable thisPiece = self.checkerBoard.allMyPieces[idx]
						if thisPiece != null
							if middleCoord == thisPiece.coord
								// another same compaign piece is in the path, cannot move
								// 在同一阵营另外一个棋子在移动路径上造成移动失败。
								moveResult = null
								break
							endif
						endif
						
						thisPiece = self.checkerBoard.allOtherPieces[idx]
						if (idx1 < steps - 1)
							if thisPiece != null
								if middleCoord == thisPiece.getOppositeCoord()
									// another opponent compaign piece is in the path, cannot move
									// 在对立阵营另外一个棋子在移动路径上造成移动失败。
									moveResult = null
									break
								endif
							endif
						endif
					next
				next
			endif
		endif
			
		if moveResult != null
			for variable idx = 0 to getNumOfPieces() - 1 step 1
				if and(self.checkerBoard.allOtherPieces[idx] != null, newCoord.equalsOppositeCoord(self.checkerBoard.allOtherPieces[idx].coord))
					// newCoord is an opposite compaign piece's coord // newCoord 在对立阵营另外一个棋子的位置。
					moveResult = self.checkerBoard.eatPiece(self.idx, idx)
					break
				endif
			next
			self.coord = newCoord
			self.status = 1
		endif
		return moveResult
	endf
endclass

class RtcMmediaOptr
	variable self supportRtcMmedia = false, supportVideo = false
	variable self displayHandle, videoOutputCtrlPos = [null, null, null, null], videoOutputHandles = [null, null]
	public function __init__(self, DISPLAYSURF, windowWidth, windowHeight, boardSize, scalingRatio)
		self.displayHandle = DISPLAYSURF
		self.supportRtcMmedia = initialize_rtc_mmedia()	// only android is supported at the moment. //当前仅仅安卓系统支持webRTC
		self.supportVideo = false
		if self.supportRtcMmedia
			self.videoOutputCtrlPos = calcVideoOutputPos(windowWidth, windowHeight, boardSize[0], boardSize[1], scalingRatio)
			if self.videoOutputCtrlPos[0] != null
				self.supportVideo = true
				self.videoOutputHandles[0] = add_rtc_video_output(self.displayHandle, self.videoOutputCtrlPos[1,0], self.videoOutputCtrlPos[1,1], self.videoOutputCtrlPos[1,2], self.videoOutputCtrlPos[1,3], False)
				self.videoOutputHandles[1] = add_rtc_video_output(self.displayHandle, self.videoOutputCtrlPos[0,0], self.videoOutputCtrlPos[0,1], self.videoOutputCtrlPos[0,2], self.videoOutputCtrlPos[0,3], False)
				start_local_stream(self.displayHandle, 0)	// start local stream // 开始本地视频流
			endif
		endif
		return self
	endf
	
	variable self remoteAddr, conn, enableSignaling = true
	public function startRTCSignalling(self, conn)
		if !self.supportRtcMmedia
			return false
		endif
		self.conn = conn
		if self.enableSignaling
			self.enableSignaling = false	// wait a while until previous signalling thread is down // 等前一个信号线程结束。
			sleep(2000)
		endif
		self.enableSignaling = true
		call local
			while self.enableSignaling
				variable rtcMsg = receive_rtc_mmedia_message(1000)
				if rtcMsg == null
					continue
				endif
				variable evtPeerId = rtcMsg[0]
				variable evtSessionId = rtcMsg[1]
				variable evtType = rtcMsg[2]
				variable evtInfo = rtcMsg[3]
				if and(evtPeerId == self.remoteAddr, evtType == "signal")
					variable signalType = get_json_field(evtInfo, "type")
					if or(signalType == "offer", signalType == "answer")
						variable signalDescription = get_json_field(evtInfo, "sdp")
						::mfp::paracomp::connect::send_sandbox_message(self.conn, [evtSessionId, ["webrtc", signalType, signalDescription]])
					elseif signalType == "candidate"
						::mfp::paracomp::connect::send_sandbox_message(self.conn, [evtSessionId, ["webrtc", signalType, evtInfo]])
					endif
				elseif and(evtPeerId == self.remoteAddr, evtType == "pc")
					variable pcType = get_json_field(evtInfo, "type")
					variable pcContent = get_json_field(evtInfo, "content")
					if and(pcType == "ice_connection_change", pcContent == "CONNECTED")
						// actually pcContent == "CONNECTED" garantees the multimedia peers have been connected.
						// pcContent == "COMPLETED" may happen or may not happen in the client side. And it may
						// happen before or after pcContent == "CONNECTED". However, what worries me is that this
						// thread in previous session didn't quit so that it eats the pcContent == "CONNECTED"
						// message and make the new thread never quit too. As such I add a timer in the MMPeer
						// signal message receiving loop. If timer expires, signal message receiving loop set
						// enableSignaling to false so that this thread can quit too.
						// 事实上，pcContent == "CONNECTED"是足以证明多媒体peer已经连接成功。在客户端，pcContent == "COMPLETED"
						// 可能发生，也可能不会发生，可能在"CONNECTED"之前发生，也可能在之后发生。让我担忧的是，前一次运行是，这个线程可能没有
						// 正确退出，这样，前一次运行的此线程可能会吃掉pcContent == "CONNECTED"消息，这样这一次运行的本线程也无法退出。
						// 为了防止这种情况发生，在多媒体peer接受信号消息的循环种我加了一个计时器，如果计时器回零，多媒体peer接受信号消息的循环
						// 将enableSignaling设置为false这样本线程也可以退出。
						break
					endif
				endif
			loop
			self.enableSignaling = false
		endcall
		return true
	endf
	
	public function stopRTCSignalling(self)
		if self.enableSignaling
			self.enableSignaling = false	// wait a while until previous signalling thread is down // 等前一个信号线程结束。
			sleep(2000)
		endif
	endf
	
	public function createOffer(self, remoteAddr)
		self.remoteAddr = remoteAddr
		if self.supportRtcMmedia
			variable supportVideoStr = "false"
			if self.supportVideo
				supportVideoStr = "true"
				link_video_stream(self.displayHandle, remoteAddr, 0, 1)
			endif
			create_rtc_media_offer(remoteAddr, [["OfferToReceiveAudio", "true"], ["OfferToReceiveVideo", supportVideoStr]], [["DtlsSrtpKeyAgreement", "true"]])
		endif
	endf
	
	public function createAnswer(self, remoteAddr, sdpType, sdpContent)
		self.remoteAddr = remoteAddr
		if self.supportRtcMmedia
			variable supportVideoStr = "false"
			if self.supportVideo
				supportVideoStr = "true"
				link_video_stream(self.displayHandle, remoteAddr, 0, 1)
			endif
			create_rtc_media_answer(remoteAddr, sdpType, sdpContent, [["OfferToReceiveAudio", "true"], ["OfferToReceiveVideo", supportVideoStr]], [["DtlsSrtpKeyAgreement", "true"]])
		endif
	endf
	
	public function setRemoteDescription(self, remoteAddr, sdpType, sdpContent)
		if self.supportRtcMmedia
			set_rtc_media_remote_description(remoteAddr, sdpType, sdpContent)
		endif
	endf
	
	public function addICECandidate(self, remoteAddr, payLoad)
		if self.supportRtcMmedia
			add_rtc_media_ice_candidate(remoteAddr, payLoad)
		endif
	endf
	
	variable self voiceOn = true, cameraOn = true
	public function setCameraVoiceState(self, voiceOnState, cameraOnState)
		self.voiceOn = voiceOnState
		self.cameraOn = cameraOnState
	endf
	public function drawCtrlButtons(self, allImages)
		if self.videoOutputCtrlPos[3] != null	// we do draw the buttons // 我们确实需要画这些按钮。
			variable isVoiceOn = "VoiceOff", isCameraOn = "CameraOff"
			if self.voiceOn
				isVoiceOn = "VoiceOn"
			endif
			if self.cameraOn
				isCameraOn = "CameraOn"
			endif
			variable ctrlBtnZoomRatio = self.videoOutputCtrlPos[2,2] / 420
			draw_image("chess", self.displayHandle, get_value_from_abdict(allImages, isVoiceOn), self.videoOutputCtrlPos[2,0], self.videoOutputCtrlPos[2,1], ctrlBtnZoomRatio, ctrlBtnZoomRatio)
			draw_image("chess", self.displayHandle, get_value_from_abdict(allImages, isCameraOn), self.videoOutputCtrlPos[3,0], self.videoOutputCtrlPos[3,1], ctrlBtnZoomRatio, ctrlBtnZoomRatio)
		endif
	endf
	public function isHitAtOutputOrCtrl(self, physicalX, physicalY)
		if self.videoOutputCtrlPos[0] == null
			return -1	// not hit either a video output window or a control button // 既没有点中视频输出窗口也没有点中控制按钮。
		elseif and(physicalX >= self.videoOutputCtrlPos[1,0], physicalX < self.videoOutputCtrlPos[1,0] + self.videoOutputCtrlPos[1,2], _
				physicalY >= self.videoOutputCtrlPos[1,1], physicalY < self.videoOutputCtrlPos[1,1] + self.videoOutputCtrlPos[1,3])
			return 0	// hit video output window in my side // 点中我这一侧的视频输出窗口。
		elseif and(physicalX >= self.videoOutputCtrlPos[0,0], physicalX < self.videoOutputCtrlPos[0,0] + self.videoOutputCtrlPos[0,2], _
				physicalY >= self.videoOutputCtrlPos[0,1], physicalY < self.videoOutputCtrlPos[0,1] + self.videoOutputCtrlPos[0,3])
			return 1	// hit video output window in the other side // 点中对方一侧的视频输出窗口。
		elseif and(physicalX >= self.videoOutputCtrlPos[2,0], physicalX < self.videoOutputCtrlPos[2,0] + self.videoOutputCtrlPos[2,2], _
				physicalY >= self.videoOutputCtrlPos[2,1], physicalY < self.videoOutputCtrlPos[2,1] + self.videoOutputCtrlPos[2,3])
			return 2	// hit voice on/off control button // 点中语音开关按钮
		elseif and(physicalX >= self.videoOutputCtrlPos[3,0], physicalX < self.videoOutputCtrlPos[3,0] + self.videoOutputCtrlPos[3,2], _
				physicalY >= self.videoOutputCtrlPos[3,1], physicalY < self.videoOutputCtrlPos[3,1] + self.videoOutputCtrlPos[3,3])
			return 3	// hit video on/off control button // 点中视频开关按钮
		else
			return -1
		endif
	endf
endclass

function print_line_(s)
    // for debugging purpose, ignore this function
	//用于调试，请忽略本函数
endf 

function FPS()
	// Sleeping interval adjuster. The larger this value is, the smaller sleeping interval
	// 用户调整睡眠时间。这个函数的返回值越大，睡眠时间越短
	return 20
endf 
 
function WINDOWDEFAULTWIDTH() 
	return 1024 // width of the program's window, in pixels // 基于像素的游戏显示窗口宽度
endf 
 
function WINDOWDEFAULTHEIGHT() 
	return 956 // height in pixels  // 基于像素的游戏显示窗口高度
endf 

function PURPLE() //紫色
	return [255, 0, 255] 
endf 
function LIGHTBLUE() //淡蓝
	return [170, 190, 255] 
endf 
function BLUE() //蓝色
	return [0, 0, 255] 
endf 
function RED() //红色
	return [255, 100, 100] 
endf 
function BLACK() //黑色
	return [0, 0, 0] 
endf 
function BROWN() //灰色
	return [85, 65, 0] 
endf

function BGCOLOR() 
	return LIGHTBLUE() // background color on the screen //屏幕背景色
endf 

function ScalingRatio(windowWidth, windowHeight, boardWidth, boardHeight)
	variable widthRatio = windowWidth / boardWidth
	variable heightRatio = windowHeight / boardHeight
	variable ratio = min(widthRatio, heightRatio)
	variable scalingRatio = floor(ratio * 16) / 16.0 // scaling ratio (only like 1, 2.25, 3.5, 2.75 are allowed) // 缩放比例（只有整数的1/16的缩放比例才被允许）
	if scalingRatio == 0
		scalingRatio = ratio
	endif
	return scalingRatio
endf

function calcVideoOutputPos(windowWidth, windowHeight, boardWidth, boardHeight, scalingRatio)
	variable edgeVertical = (windowHeight - scalingRatio * boardHeight)/2.0
	variable edgeHorizontal = (windowWidth - scalingRatio * boardWidth)/2.0
	if edgeVertical + edgeHorizontal < 100
		return [null, null, null, null]	// the screen is too small
	elseif edgeVertical * windowWidth > edgeHorizontal * windowHeight
		// video window is placed vertically
		variable height = 0.9 * edgeVertical
		variable width = height * windowWidth / windowHeight
		variable left = (windowWidth - width)/2.0
		variable top0 = 0.05 * edgeVertical
		variable top1 = windowHeight - 0.05 * edgeVertical - height
		variable controlButtonSize = min((windowWidth - width) / 2, edgeVertical)*0.4
		variable ctrlBtnTop = windowHeight - (edgeVertical - controlButtonSize) / 2 - controlButtonSize
		variable ctrlBtnLeft0 = ((windowWidth - width) / 2 - controlButtonSize) / 2
		variable ctrlBtnLeft1 = windowWidth - controlButtonSize - ctrlBtnLeft0
		return [[left, top0, width, height], [left, top1, width, height], _
				[ctrlBtnLeft0, ctrlBtnTop, controlButtonSize, controlButtonSize], _
				[ctrlBtnLeft1, ctrlBtnTop, controlButtonSize, controlButtonSize]]
	else
		// video window is placed horizontally
		variable width = 0.9 * edgeHorizontal
		variable height = width * windowHeight / windowWidth
		variable top = (windowHeight - height)/2.0
		variable left0 = 0.05 * edgeHorizontal
		variable left1 = windowWidth - 0.05 * edgeHorizontal - width
		variable controlButtonSize = min((windowHeight - height) / 2, edgeHorizontal)*0.4
		variable ctrlBtnTop0 = ((windowHeight - height) / 2 - controlButtonSize) / 2
		variable ctrlBtnTop1 = windowHeight - controlButtonSize - ctrlBtnTop0
		variable ctrlBtnLeft = windowWidth - (edgeHorizontal - controlButtonSize) / 2 - controlButtonSize
		return [[left0, top, width, height], [left1, top, width, height], _
				[ctrlBtnLeft, ctrlBtnTop0, controlButtonSize, controlButtonSize], _
				[ctrlBtnLeft, ctrlBtnTop1, controlButtonSize, controlButtonSize]]
	endif
endf

function getLeftTopBoard(windowWidth, windowHeight, boardWidth, boardHeight, scalingRatio)
	variable left = (windowWidth - boardWidth * scalingRatio) / 2
	variable top = (windowHeight - boardHeight * scalingRatio) / 2
	return [left, top]
endf

function getLeftTopPiece(color, boardLeft, boardTop, boardScaledW, boardScaledH, xIdx, yIdx)
	// note that boardPhysicalW and boardPhysicalH may not be the image's width and height.
	//注意boardPhysicalW和boardPhysicalH可能和图片的宽和高不一样。
	variable ratio = 3
	variable boardPhysicalW = 1136 * ratio, boardPhysicalH = 1136 * ratio, board0L = 140 * ratio, board0T = 995 * ratio, boardStep = 122.5 * ratio, piecePhysicalW = 121 * ratio, piecePhysicalH = 121 * ratio
	if !color
		xIdx = 7 - xIdx
		yIdx = 7 - yIdx
	endif
	variable pieceLeft = (board0L + xIdx * boardStep - piecePhysicalW / 2) * boardScaledW / boardPhysicalW + boardLeft
	variable pieceTop = (board0T - yIdx * boardStep - piecePhysicalH / 2) * boardScaledH / boardPhysicalH + boardTop
	return [pieceLeft, pieceTop]	
endf

function getIdxXY(color, physicalX, physicalY, scalingRatio, boardLeft, boardTop)
	variable ratio = 3
	variable board0L = 140 * ratio * scalingRatio, board0T = 995 * ratio * scalingRatio, boardStep = 122.5 * ratio * scalingRatio
	variable idxX = round((physicalX - boardLeft - board0L) / boardStep)
	variable idxY = round((board0T - physicalY + boardTop) / boardStep)
	if or(idxX < 0, idxX > 7, idxY < 0, idxY >7)
		return [-1, -1]
	elseif color 	// white // 白方
		return [idxX, idxY]
	else	// black	// 黑方
		return [7 - idxX, 7 - idxY]
	endif
endf

function detectVideoOutputCtrlHit(DISPLAYSURF, rtcMmediaMgr, local_interface, another_player_address, conn, round)
	variable clickedVideoOutputCtrl = -1
	variable quitLoop = True, lastMouseDownX = null, lastMouseDownY = null
	// processing player's input events. Note that because we are waiting for 
	// action from the other side, we ignore any hit or movement of the piece
	// 处理玩家输入事件。注意此时我们在等待对方的输入所以我们忽略所有点击棋子的事件。
	do
		variable giEvent = pull_event(DISPLAYSURF) 
		if giEvent != Null 
			if get_event_type_name(giEvent) == "GDI_CLOSE" 
				// quit // 退出
				if conn != null
					::mfp::paracomp::connect::send_sandbox_message(conn, [round, "game-quit"])
					close_rtc_media_peer(another_player_address)
					close_local(local_interface)
				endif
				stop_local_stream(DISPLAYSURF)
				// todo can only connect once for webrtc haven't tested tcp, moreover, webrtc local address has to be pre setup
				return -2 
			elseif get_event_type_name(giEvent) == "POINTER_UP" 
				// find out clicked video output window or control button.
				// 找到被点击的视频输出窗口或者控制按钮。
				if and(lastMouseDownX != null, lastMouseDownY != null)
					clickedVideoOutputCtrl = rtcMmediaMgr.isHitAtOutputOrCtrl(lastMouseDownX, lastMouseDownY)
					break
				endif
			elseif get_event_type_name(giEvent) == "POINTER_DOWN" 
				// this is the start of a mouse click/finger tap or mouse/finger drag 
				// 这是一个点击或者拖拽事件的开始。
				quitLoop = False
				lastMouseDownX = get_event_info(giEvent, "x") 
				lastMouseDownY = get_event_info(giEvent, "y") 
			endif
		endif
	until quitLoop 
	if clickedVideoOutputCtrl >= 0 // video output window or control button is hit //视频窗口或控制按钮被点中
		if clickedVideoOutputCtrl == 2
			rtcMmediaMgr.voiceOn = !rtcMmediaMgr.voiceOn
			set_audio_track_enable(DISPLAYSURF, rtcMmediaMgr.voiceOn)
		elseif clickedVideoOutputCtrl == 3
			rtcMmediaMgr.cameraOn = !rtcMmediaMgr.cameraOn
			set_video_track_enable(DISPLAYSURF, rtcMmediaMgr.cameraOn)
		endif
	endif
	return clickedVideoOutputCtrl
endf

// entry point of chinese chess game
// 中国象棋游戏的入口函数
function start_cchess(protocol, local_address, another_player_address) 
	// open screen display window for the game
	// 为游戏开启一个显示窗口
	variable DISPLAYSURF = open_screen_display("Chinese Chess", BGCOLOR(), true, [WINDOWDEFAULTWIDTH(), WINDOWDEFAULTHEIGHT()], false, 1)
	
	// set constant value into variables to accelerate calculation
	// 将常数值保存在变量中避免重复计算以加快计算速度
	variable windowWidth = get_display_size(DISPLAYSURF)[0], windowHeight = get_display_size(DISPLAYSURF)[1]
	// it is possible that in some very small devices, DISPLAYSURF is still not ready when get_display_size is called,
	// so wait for a few seconds.
	// 在一些很慢的设备上，有可能出现调用get_display_size函数时，DISPLAYSURF还没有初始化好（也就是它的宽度高度为0），所以，必须等待几秒钟。
	variable waitSecond = 0
	while and(or(windowWidth <= 0, windowHeight <= 0), waitSecond <= 4)
		sleep(1000)
		windowWidth = get_display_size(DISPLAYSURF)[0]
		windowHeight = get_display_size(DISPLAYSURF)[1]
		waitSecond = waitSecond + 1
	loop	
	// copy image files to Apk asset when building MFP app.
	// 在创建MFP应用时，必须将图像文件拷贝到应用APK包的asset目录中
	variable allImages = create_abdict()
	variable allImageNames = ["ChessCheckerBoard", "BBishop", "BQueen", "BKing", "BKnight", "BPawn", "BRook", _
							"WBishop", "WQueen", "WKing", "WKnight", "WPawn", "WRook", "SelectedChessPiece", _
							"VoiceOn", "VoiceOff", "CameraOn", "CameraOff"]
	@build_asset copy_to_resource(iff(is_sandbox_session(), get_sandbox_session_resource_path() + "charts", _
									is_mfp_app(), [1, get_asset_file_path("resource"), "charts"], _
									get_upper_level_path(get_src_file_path())), "charts")
	for variable idx = 0 to size(allImageNames)[0] - 1 step 1
		variable thismage
		if is_sandbox_session()
			// if in a sandbox session // 如果是在一个沙盒中运行
			thismage = load_image(get_sandbox_session_resource_path() + "charts/" + allImageNames[idx] + ".png")
		elseif is_mfp_app()
			// if mfp app is running // 如果是MFP应用
			thismage = load_image_from_zip(get_asset_file_path("resource"), "charts/" + allImageNames[idx] + ".png", 1)
		else
			// if a script file is running // 如果运行的是脚本
			thismage = load_image(get_upper_level_path(get_src_file_path()) + "" + allImageNames[idx] + ".png") 
		endif
		allImages = set_value_in_abdict(allImages, allImageNames[idx], thismage)
	next
	
	variable boardSize = get_image_size(get_value_from_abdict(allImages, "ChessCheckerBoard"))
	variable scalingRatio = ScalingRatio(windowWidth, windowHeight, boardSize[0], boardSize[1])
print_line("scalingRatio = " + scalingRatio + " windowWidth = " + windowWidth + " windowHeight = " + windowWidth + " boardSize = " + boardSize)
	
	variable rtcMmediaMgr = RtcMmediaOptr().__init__(DISPLAYSURF, windowWidth, windowHeight, boardSize, scalingRatio)
	
	variable boardScaledSize = boardSize * scalingRatio
	variable boardLeftTop = getLeftTopBoard(windowWidth, windowHeight, boardSize[0], boardSize[1], scalingRatio)

	variable ccheckBoard = CCheckerBoard()

	variable round = 0
	variable allowedGameStarts = 1	// this variable tells server how many clients have connected to it (only 1 allowed). //这个变量告诉服务器有多少客户端曾经连接过它（只允许1个）

	// setup interface and connection // 设置网络界面和连接
	variable local_interface, remote_interface, conn, ret
	local_interface = ::mfp::paracomp::connect::generate_interface(protocol, local_address)
	ret = ::mfp::paracomp::connect::initialize_local(local_interface)	// create local_interface. 创建local_interface本地网络界面
	print("initialize_local ret = " + ret + "\n")
	ret = ::mfp::paracomp::connect::listen(local_interface)
	print("listen ret = " + ret + "\n")
	if !ret
		throw "Cannot listen to " + local_interface
	endif
	if strlen(another_player_address) > 0
		// the player is client. 玩家是客户端。
		allowedGameStarts = 0
		variable waitingText = local_address + ":\nnow connecting to the other player.\nThe other player's address is " + another_player_address + ".\nPlease wait a while..."
		if get_country_language()[1] == "zh"
			waitingText = local_address + ":\n准备加入棋局，现在开始链接对方棋手。\n对方棋手的地址是" + another_player_address + "。\n请稍等片刻..."
		endif
		variable textOrigin = calculate_text_origin(DISPLAYSURF, waitingText, [0, 0], windowWidth, windowHeight, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, waitingText, textOrigin, getTextColor(), getTextFontSize())
		update_display(DISPLAYSURF)

		variable server_address = another_player_address
		remote_interface = ::mfp::paracomp::connect::generate_interface(protocol, server_address)	// server address
		ret = ::mfp::paracomp::connect::connect(local_interface, remote_interface, true)
		print("connect ret = " + ret + "\n")

		conn = ::mfp::data_struct::array_based::get_value_from_abdict(ret, "CONNECT")
		if (conn == null)
			variable errMsg = ::mfp::data_struct::array_based::get_value_from_abdict(ret, "ERROR")
			waitingText = "Fail to connect from " + local_address + " to " + another_player_address + ".\nError message: " + errMsg
			if get_country_language()[1] == "zh"
				waitingText = "从" + local_address + "到" + another_player_address + "无法建立连接。\n错误消息：" + errMsg
			endif
			drop_old_painting_requests("chess", DISPLAYSURF)
			variable textOrigin = calculate_text_origin(DISPLAYSURF, waitingText, [0, 0], windowWidth, windowHeight, 0, 0, getTextFontSize()) 
			draw_text("chess", DISPLAYSURF, waitingText, textOrigin, getTextColor(), getTextFontSize())
			update_display(DISPLAYSURF)
		endif
		rtcMmediaMgr.startRTCSignalling(conn)
		
		// now lets send start message to server.
		// 现在发送启动消息给服务端
		::mfp::paracomp::connect::send_sandbox_message(conn, [0, "game-start"])

		// initialize checkerboard // 初始化棋盘
		ccheckBoard.__init__(False)
		// redraw checker board //重新绘制棋盘
		ccheckBoard.draw(DISPLAYSURF, allImages, rtcMmediaMgr, boardLeftTop[0], boardLeftTop[1], boardScaledSize[0], boardScaledSize[1], scalingRatio, null)
	else
		// the player is server. 玩家是服务端。
		variable waitingText = local_address + ": waiting for the other player..."
		if get_country_language()[1] == "zh"
			waitingText = local_address + ": 等待对手玩家加入棋局..."
		endif
		variable textOrigin = calculate_text_origin(DISPLAYSURF, waitingText, [0, 0], windowWidth, windowHeight, 0, 0, getTextFontSize()) 
		draw_text("chess", DISPLAYSURF, waitingText, textOrigin, getTextColor(), getTextFontSize())
		update_display(DISPLAYSURF)
		// alternatively, we can call get_incoming_connect later to retrieve connect at server side
		// 还有一个办法是在后面某个时候调用函数get_incoming_connect在服务端取回连接对象。
		//ret = accept(local_interface)
	endif
	variable myColor = (strlen(another_player_address) == 0) // client is black, while server is white //客户端是黑色，服务端是白色

	while true // main game loop // 主循环
		// then we retrieve a message // 然后我们读取以条消息。
		variable msg = receive_sandbox_message(local_interface, 100)	// unblock mode.非阻塞模式。
		if msg == null
			if strlen(another_player_address) > 0
				// do this only if we are waiting for the other side's move and the checkboard is shown
				// 只有当我们在等对方出子并且棋盘已经显现才运行以下代码。
				variable hitItem = detectVideoOutputCtrlHit(DISPLAYSURF, rtcMmediaMgr, local_interface, another_player_address, conn, round)
				if hitItem == -2
					return True	// quit //退出
				else
					if or(hitItem == 2, hitItem == 3)	// hit control button // 点中控制按钮
						// redraw checker board //重新绘制棋盘
						ccheckBoard.draw(DISPLAYSURF, allImages, rtcMmediaMgr, boardLeftTop[0], boardLeftTop[1], boardScaledSize[0], boardScaledSize[1], scalingRatio, null)
					endif
				endif
			endif
			continue
		endif
		variable interface_info = ::mfp::data_struct::array_based::get_value_from_abdict(msg, "InterfaceInfo")
		variable connect_id = ::mfp::data_struct::array_based::get_value_from_abdict(msg, "TransConnectDestRemote")
		variable msg_round_and_data = ::mfp::data_struct::array_based::get_value_from_abdict(msg, "Message")
		if size(msg_round_and_data)[0] != 2
			continue	// this is not a valid message // 消息不合法
		endif
		variable msgRound = msg_round_and_data[0]
		variable msg_data = msg_round_and_data[1]
		if or(size(msg_data) != [3], msg_data[0] != "webrtc")
			if msgRound == 0
				allowedGameStarts = allowedGameStarts - 1
			endif
			if or(allowedGameStarts < 0, and(allowedGameStarts > 0, msgRound > 0))
				variable waitingText = "Invalid round\nPlease restart"
				if get_country_language()[1] == "zh"
					waitingText = "非法棋局\n请退出重新开始"
				endif
				variable textOrigin = calculate_text_origin(DISPLAYSURF, waitingText, [0, 0], windowWidth, windowHeight, 0, 0, getTextFontSize()) 
				draw_text("chess", DISPLAYSURF, waitingText, textOrigin, getTextColor(), getTextFontSize())
				update_display(DISPLAYSURF)
				break
			else
				round = msgRound
			endif
		endif

		if and(size(msg_data) == [3], msg_data[0] == "webrtc")
			// this is a webrtc signal // 这是一个webrtc信号
			variable rtcType = msg_data[1]
			variable rtcDescription = msg_data[2]
			if rtcType == "offer"
				rtcMmediaMgr.createAnswer(connect_id, rtcType, rtcDescription)
			elseif rtcType == "answer"
				rtcMmediaMgr.setRemoteDescription(connect_id, rtcType, rtcDescription)
			elseif rtcType == "candidate"
				rtcMmediaMgr.addICECandidate(connect_id, rtcDescription)
			endif
		elseif msg_data == "game-quit"
			variable waitingText = "Player quit"
			if get_country_language()[1] == "zh"
				waitingText = "对方已经退赛"
			endif
			if and(ccheckBoard != null, ccheckBoard.isInitialized())
				ccheckBoard.draw(DISPLAYSURF, allImages, rtcMmediaMgr, boardLeftTop[0], boardLeftTop[1], boardScaledSize[0], boardScaledSize[1], scalingRatio, waitingText)
			else
				variable textOrigin = calculate_text_origin(DISPLAYSURF, waitingText, [0, 0], windowWidth, windowHeight, 0, 0, getTextFontSize()) 
				draw_text("chess", DISPLAYSURF, waitingText, textOrigin, getTextColor(), getTextFontSize())
				update_display(DISPLAYSURF)
			endif
			break
		else
			if msg_data == "game-start"	// the game is started // 比赛开始
				// the player is server. 玩家是服務端。
				//remote_interface = ::mfp::paracomp::connect::generate_interface(protocol, connect_id)	// remote address
				//ret = ::mfp::paracomp::connect::connect(local_interface, remote_interface, false)
				//print("connect ret = " + ret + "\n")
				ret = get_incoming_connect(local_interface, connect_id)
				print("get_incoming_connect connect_id = " + connect_id + " ret = " + ret + "\n")
				//print("accept ret = " + ret + "\n")
				conn = ::mfp::data_struct::array_based::get_value_from_abdict(ret, "CONNECT")
				if conn == null
					// failed to connect back from server to client // 从服务端连接客户端失败
					variable errorMsg = ::mfp::data_struct::array_based::get_value_from_abdict(ret, "ERROR")
					drop_old_painting_requests("chess", DISPLAYSURF)
					variable textOrigin = calculate_text_origin(DISPLAYSURF, errorMsg, [0, 0], windowWidth, windowHeight, 0, 0, getTextFontSize()) 
					draw_text("chess", DISPLAYSURF, errorMsg, textOrigin, getTextColor(), getTextFontSize())
					update_display(DISPLAYSURF)
					break
				else
					round = round + 1	// go into the next round // 进入下一轮
					another_player_address = connect_id
					rtcMmediaMgr.startRTCSignalling(conn)
					rtcMmediaMgr.createOffer(connect_id)	// video connection starts //开始视频连接
					variable startTime = now()
					while and(rtcMmediaMgr.enableSignaling, now() - startTime < 120000)
						variable msg = receive_sandbox_message(local_interface, 1000)	// unblock mode.非阻塞模式。
						if msg == null
							continue
						endif
						variable interface_info = ::mfp::data_struct::array_based::get_value_from_abdict(msg, "InterfaceInfo")
						variable connect_id = ::mfp::data_struct::array_based::get_value_from_abdict(msg, "TransConnectDestRemote")
						variable msg_round_and_data = ::mfp::data_struct::array_based::get_value_from_abdict(msg, "Message")
						if size(msg_round_and_data)[0] != 2
							continue	// this is not a valid message // 消息不合法
						endif
						variable msgRound = msg_round_and_data[0]
						variable msg_data = msg_round_and_data[1]

						if and(size(msg_data) == [3], msg_data[0] == "webrtc")
							// this is a webrtc signal // 这是一个webrtc信号
							variable rtcType = msg_data[1]
							variable rtcDescription = msg_data[2]
							if rtcType == "offer"
								rtcMmediaMgr.createAnswer(connect_id, rtcType, rtcDescription)
							elseif rtcType == "answer"
								rtcMmediaMgr.setRemoteDescription(connect_id, rtcType, rtcDescription)
							elseif rtcType == "candidate"
								rtcMmediaMgr.addICECandidate(connect_id, rtcDescription)
							endif
						endif
					loop
					rtcMmediaMgr.enableSignaling = false	// force MMPeer event consuming thread to quit // 强制多媒体Peer事件处理线程退出。
					// initialize checkerboard // 初始化棋盘
					ccheckBoard.__init__(True)
					// redraw checker board //重新绘制棋盘
					// information about this round // 这一局的信息
					variable waitingText = "New game started"
					if get_country_language()[1] == "zh"
						waitingText = "开始新的一局"
					endif
					ccheckBoard.draw(DISPLAYSURF, allImages, rtcMmediaMgr, boardLeftTop[0], boardLeftTop[1], boardScaledSize[0], boardScaledSize[1], scalingRatio, waitingText)
				endif
			else
				// the other player has moved a piece // 对手移动了一个棋子
				variable pieceEaten = ccheckBoard.updatePieces(msg_data)
				if pieceEaten != null
					@build_asset copy_to_resource(iff(is_sandbox_session(), get_sandbox_session_resource_path() + "eatmove.wav", _
												is_mfp_app(), [1, get_asset_file_path("resource"), "eatmove.wav"], _
												get_upper_level_path(get_src_file_path()) + "eatmove.wav"), "sounds/eatmove.wav")
					if is_sandbox_session()
						play_sound(get_sandbox_session_resource_path() + "sounds/eatmove.wav", false)
					elseif is_mfp_app()
						play_sound_from_zip(get_asset_file_path("resource"), "sounds/eatmove.wav", 1, false)
					else
						play_sound(get_upper_level_path(get_src_file_path()) + "eatmove.wav", false) 
					endif
				endif
				// redraw checker board //重新绘制棋盘
				variable waitingText = "My turn"
				if get_country_language()[1] == "zh"
					waitingText = "该我走了"
				endif
				ccheckBoard.draw(DISPLAYSURF, allImages, rtcMmediaMgr, boardLeftTop[0], boardLeftTop[1], boardScaledSize[0], boardScaledSize[1], scalingRatio, waitingText)
			endif

			// it is our turn //现在该我们了。
			variable selectedIdx = -1, moveResult = null
			variable clickedVideoOutputCtrl = -1, clickedPieceIdx = [-1, -1]
			while moveResult == null
				variable lastMouseDownX = null, lastMouseDownY = null
				do // processing player's input events // 处理玩家输入事件
					variable giEvent = pull_event(DISPLAYSURF) 
					if giEvent == Null 
						// no event to handle // 没有需要处理的事件
						continue
					elseif get_event_type_name(giEvent) == "GDI_CLOSE" 
						// quit // 退出
						::mfp::paracomp::connect::send_sandbox_message(conn, [round, "game-quit"])
						close_rtc_media_peer(another_player_address)
						stop_local_stream(DISPLAYSURF)
						close_local(local_interface)
						// todo can only connect once for webrtc haven't tested tcp, moreover, webrtc local address has to be pre setup
						return True 
					elseif get_event_type_name(giEvent) == "POINTER_UP" 
						// find out clicked piece.
						// 找到被点击的棋子。
						if and(lastMouseDownX != null, lastMouseDownY != null)
							clickedVideoOutputCtrl = rtcMmediaMgr.isHitAtOutputOrCtrl(lastMouseDownX, lastMouseDownY)
							if clickedVideoOutputCtrl < 0	// no piece was hit // 没有棋子被点中
								clickedPieceIdx = getIdxXY(myColor, lastMouseDownX, lastMouseDownY, scalingRatio, boardLeftTop[0], boardLeftTop[1])
							endif
							break
						endif
					elseif get_event_type_name(giEvent) == "POINTER_DOWN" 
						// this is the start of a mouse click/finger tap or mouse/finger drag 
						// 这是一个点击或者拖拽事件的开始。
						lastMouseDownX = get_event_info(giEvent, "x") 
						lastMouseDownY = get_event_info(giEvent, "y") 
					endif 
				until false 
				if clickedVideoOutputCtrl >= 0 // video output window or control button is hit //视频窗口或控制按钮被点中
					if clickedVideoOutputCtrl == 2
						rtcMmediaMgr.voiceOn = !rtcMmediaMgr.voiceOn
						set_audio_track_enable(DISPLAYSURF, rtcMmediaMgr.voiceOn)
					elseif clickedVideoOutputCtrl == 3
						rtcMmediaMgr.cameraOn = !rtcMmediaMgr.cameraOn
						set_video_track_enable(DISPLAYSURF, rtcMmediaMgr.cameraOn)
					endif
				else 
					variable piece = ccheckBoard.findSelectedPiece(clickedPieceIdx)
					if or(piece == null, piece.color != ccheckBoard.color)
						if ccheckBoard.selectedIdx != -1
							// this means we move the selected piece to a new coord //这意味着我们将要移动选中的棋子。
							variable destCoord = CCheckerBoardCoord().__init__(clickedPieceIdx)
							moveResult = ccheckBoard.allMyPieces[ccheckBoard.selectedIdx].move(destCoord)
							if moveResult == null
								@build_asset copy_to_resource(iff(is_sandbox_session(), get_sandbox_session_resource_path() + "badmove.wav", _
																is_mfp_app(), [1, get_asset_file_path("resource"), "badmove.wav"], _
																get_upper_level_path(get_src_file_path()) + "badmove.wav"), "sounds/badmove.wav")
								if is_sandbox_session()
									play_sound(get_sandbox_session_resource_path() + "sounds/badmove.wav", false)
								elseif is_mfp_app()
									play_sound_from_zip(get_asset_file_path("resource"), "sounds/badmove.wav", 1, false)
								else
									play_sound(get_upper_level_path(get_src_file_path()) + "badmove.wav", false) 
								endif
							elseif moveResult == ""
								@build_asset copy_to_resource(iff(is_sandbox_session(), get_sandbox_session_resource_path() + "goodmove.wav", _
																is_mfp_app(), [1, get_asset_file_path("resource"), "goodmove.wav"], _
																get_upper_level_path(get_src_file_path()) + "goodmove.wav"), "sounds/goodmove.wav")
								if is_sandbox_session()
									play_sound(get_sandbox_session_resource_path() + "sounds/goodmove.wav", false)
								elseif is_mfp_app()
									play_sound_from_zip(get_asset_file_path("resource"), "sounds/goodmove.wav", 1, false)
								else
									play_sound(get_upper_level_path(get_src_file_path()) + "goodmove.wav", false) 
								endif
								ccheckBoard.selectedIdx = -1
							else 	// eat a piece //吃了对方一个子
								@build_asset copy_to_resource(iff(is_sandbox_session(), get_sandbox_session_resource_path() + "eatmove.wav", _
																is_mfp_app(), [1, get_asset_file_path("resource"), "eatmove.wav"], _
																get_upper_level_path(get_src_file_path()) + "eatmove.wav"), "sounds/eatmove.wav")
								if is_sandbox_session()
									play_sound(get_sandbox_session_resource_path() + "sounds/eatmove.wav", false)
								elseif is_mfp_app()
									play_sound_from_zip(get_asset_file_path("resource"), "sounds/eatmove.wav", 1, false)
								else
									play_sound(get_upper_level_path(get_src_file_path()) + "eatmove.wav", false) 
								endif
								ccheckBoard.selectedIdx = -1
							endif
						else
							// this means no piece has been selected and we do nothing //这意味着我们没有选中棋子所以什么都不做
						endif
					elseif and(piece != null, piece.color == ccheckBoard.color)
						// this means we selected a piece but we haven't moved it, do nothing
						// 这意味这我们选中了一个棋子但是还没有移动它，所以什么都不做。
						selectedIdx = piece.idx
					endif
				endif
				variable waitingText = null
				if moveResult == null
					waitingText = "My turn"
					if get_country_language()[1] == "zh"
						waitingText = "该我走了"
					endif
				endif
				ccheckBoard.draw(DISPLAYSURF, allImages, rtcMmediaMgr, boardLeftTop[0], boardLeftTop[1], boardScaledSize[0], boardScaledSize[1], scalingRatio, waitingText)
				// sleep a while to avoid blinking because updating screen too fast.
				// 休眠一会儿，避免更新屏幕太快以至于出现闪烁。 
				sleep(1500/FPS())
			loop
			// conn and clickedPieceIdx must not be null // conn和clickedPieceIdx一定不是null
			::mfp::paracomp::connect::send_sandbox_message(conn, [round, [selectedIdx, clickedPieceIdx[0], clickedPieceIdx[1], moveResult]])
		endif
	loop
	close_rtc_media_peer(another_player_address)
	stop_local_stream(DISPLAYSURF)
	return False
endf

// assume interface_addr has been trimmed
// 假定interface_addr已经被截去两头的空白字符
function is_valid_ip4address(interfaceAddr, localhostNotAllowed)
	if interfaceAddr == "localhost"
		if localhostNotAllowed
			return false
		else
			return true
		endif
	else
		variable addrParts = sscanf(interfaceAddr, "%d.%d.%d.%d")
		if size(addrParts)[0] != 4
			return false
		else
			for variable idx = 0 to size(addrParts)[0] - 1 step 1
				if or(addrParts[idx] < 0, addrParts[idx] > 255)
					return false
				endif
			next
			if and(localhostNotAllowed, addrParts[0] == 127)
				return false
			endif
		endif
		return true
	endif
endf

function get_valid_host_addresses(protocol, ipLocalhostNotAllowed)
        variable all_local_addresses = get_all_host_addresses(protocol)[0,1]
	variable all_valid_addresses = []
        for variable index = 0 to size(all_local_addresses)[0] - 1 step 1
                variable all_interface_addresses = all_local_addresses[index]
                if size(all_interface_addresses[1])[0] == 0
                        continue
		elseif to_uppercase_string(protocol) == "TCPIP"
                	for variable index1 = 0 to size(all_interface_addresses)[1] - 1 step 1
                        	variable interface_addr = all_interface_addresses[1,index1]
				if is_valid_ip4address(interface_addr, ipLocalhostNotAllowed)
					all_valid_addresses = append_elem_to_ablist(all_valid_addresses, interface_addr)
				endif
                	next
		else	// WEBRTC
			variable webRTCAddr = all_interface_addresses[1, 0]
			variable addrParts = split(webRTCAddr, "@")
			if and(size(addrParts)[0] == 2, strlen(trim(addrParts[0])) + strlen(trim(addrParts[1])) == strlen(webRTCAddr) - 1)
				// this is a valid email address
				// 此email地址合法
				all_valid_addresses = append_elem_to_ablist(all_valid_addresses, webRTCAddr)
			endif
                endif
        next
	return all_valid_addresses
endf

function set_protocol()
	if is_running_on_android()
		// running on Android means we can select WebRTC protocol
		// 在安卓上运行意味着我们可以选择使用WebRTC协议
		if get_country_language()[1] == "zh"
			print("请告诉我您准备选用何种通信协议和对方联系。\n如果是TCPIP请直接按Enter或者输入0再按Enter。\n如果是使用基于email信道的WebRTC协议，请输入1再按Enter键。\n请注意两位棋手必须选择相同的协议。\n")
		else
			print("Please tell me which protocol you want to use.\nPress Enter or press 0 then Enter to select TCPIP.\nPress 1 then Enter to select email addressed WebRTC protocol.\n")
			print("Note that two players must select the same protocol.\n")
		endif
		variable protocol = input("", "S")
		if or(trim(protocol) == "", trim(protocol) == "0")
			protocol = "TCPIP"
		else
			protocol = "WEBRTC"
		endif
		return protocol
	else
		return "TCPIP"
	endif
endf

function set_webrtc_addr_info(my_address)
	variable passwordPrompt = "Please input password: "
	if get_country_language()[1] == "zh"
		passwordPrompt = "请输入密码： "
	endif
	variable password = input(passwordPrompt, "S")
	variable emailParts = split(my_address, "@")
	variable additionalInfo = ["0", password]	// 0 means smtp/imap
	if size(emailParts)[0] == 2
		if or(emailParts[1] == "163.com", emailParts[1] == "126.com", emailParts[1] == "yeah.net")
			if get_country_language()[1] == "zh"
				print("由于网易限制JAVA客户端通过IMAP收取邮件，网易邮箱不被支持。建议使用微软outlook邮件或者腾讯qq邮件，注意qq邮件服务必须打开smtp和imap服务。\n")
			else
				print("Because this email service provider forbids JAVA mail client to pull emails using IMAP protocol, it is not supported. Outlook mail service is recommended.\n")
			endif
			return null
		elseif and(emailParts[1] != "gmail.com", _
				emailParts[1] != "outlook.com", emailParts[1] != "hotmail.com", emailParts[1] != "msn.com", _
				emailParts[1] != "qq.com", emailParts[1] != "yahoo.com", emailParts[1] != "sohu.com")
			variable smtpServerPrompt = "Please input smtp server address: "
			if get_country_language()[1] == "zh"
				smtpServerPrompt = "请输入smtp服务器地址： "
			endif
			variable smtpServer = input(smtpServerPrompt, "S")
			smtpServer = trim(smtpServer)
			variable smtpPortPrompt = "Please input smtp server port: "
			if get_country_language()[1] == "zh"
				smtpPortPrompt = "请输入smtp服务器端口： "
			endif
			variable smtpPort = input(smtpPortPrompt, "S")
			smtpPort = trim(smtpPort)
			variable smtpSSLPrompt = "Does smtp server support SSL (0 means no, 1 means yes): "
			if get_country_language()[1] == "zh"
				smtpSSLPrompt = "smtp服务器支持SSL吗（输入0意味着不支持，输入1意味着支持）： "
			endif
			variable smtpSSL = input(smtpSSLPrompt, "S")
			smtpSSL = trim(smtpSSL)
			variable imapServerPrompt = "Please input imap server address: "
			if get_country_language()[1] == "zh"
				imapServerPrompt = "请输入imap服务器地址： "
			endif
			variable imapServer = input(imapServerPrompt, "S")
			imapServer = trim(imapServer)
			variable imapPortPrompt = "Please input imap server port: "
			if get_country_language()[1] == "zh"
				imapPortPrompt = "请输入imap服务器端口： "
			endif
			variable imapPort = input(imapPortPrompt, "S")
			imapPort = trim(imapPort)
			variable imapSSLPrompt = "Does imap server support SSL (0 means no, 1 means yes): "
			if get_country_language()[1] == "zh"
				imapSSLPrompt = "imap服务器支持SSL吗（输入0意味着不支持，输入1意味着支持）： "
			endif
			variable imapSSL = input(imapSSLPrompt, "S")
			imapSSL = trim(imapSSL)
			additionalInfo = ["0", password, smtpServer, smtpPort, smtpSSL, imapServer, imapPort, imapSSL]
		endif
	endif
	return additionalInfo
endf

function select_local_address(protocol, ipLocalhostNotAllowed)
	variable addresses = get_valid_host_addresses(protocol, ipLocalhostNotAllowed)
	variable my_address = ""
	if size(addresses)[0] == 1
		if get_country_language()[1] == "zh"
			print("本机地址为："+ addresses[0] + "\n")
		else
			print("The address " + addresses[0] + " will be used as local address\n")
		endif
		if protocol == "WEBRTC"
			while True
				if get_country_language()[1] == "zh"
					print("按回车选择使用email地址" + addresses[0] + "，或者输入一个新的email地址（必须小写）：\n")
				else
					print("Press enter to use email address " + addresses[0] + ", or type in a new email address (always lowercase):\n")
				endif
				my_address = input("", "S")
				my_address = trim(my_address)
				if strlen(my_address) == 0
					my_address = addresses[0]
				else
					variable additionalInfo = set_webrtc_addr_info(my_address)
					if additionalInfo == null
						continue
					endif
					set_local_host_address(protocol, "main", my_address, additionalInfo)
				endif
				break
			loop
		else
			my_address = addresses[0]
		endif
	elseif size(addresses)[0] == 0
		while True
			if get_country_language()[1] == "zh"
				print("找不到合法的本机地址，请手工输入本机地址（注意如果是email地址，所有的字母将被转换为小写）：\n")
			else
				print("No valid address found in your device. Please input local address (all the letters will be converted to small case for email address):\n")
			endif
			my_address = input("", "S")
			my_address = trim(my_address)
			variable additionalInfo = []
			if protocol == "WEBRTC"
				additionalInfo = set_webrtc_addr_info(my_address)
				if additionalInfo == null
					continue
				endif
			endif
			set_local_host_address(protocol, "main", my_address, additionalInfo)
			break
		loop
	else
		variable addressIdx = 0
		do
			if get_country_language()[1] == "zh"
				print("找到以下本机地址，请输入1，2或者3...然后回车选择合适的本机地址：\n")
			else
				print("I have found the following addresses. Please type 1, 2 or 3... and Enter to select the correct one:\n")
			endif
			for variable idx = 0 to size(addresses)[0] - 1 step 1
				print_line((idx + 1) + " : " + addresses[idx])
			next
			addressIdx = input("", "S")
			addressIdx = sscanf(addressIdx, "%d")
			if size(addressIdx)[0] != 1
				continue	// invalid input //非法输入
			endif
		until and(addressIdx > 0, addressIdx <= size(addresses)[0])
		my_address = addresses[addressIdx - 1]
		if get_country_language()[1] == "zh"
			print("本机地址为："+ my_address + "\n")
		else
			print("The address " + my_address + " will be used\n")
		endif
	endif
	return my_address
endf

function main()
	variable protocol = set_protocol(), local_address, server_address
		
	variable my_address = select_local_address(protocol, true)
	variable inputStr = "Address of another player who has joined the game, or simply press ENTER if you are the first player:\n"
	if get_country_language()[1] == "zh"
		inputStr = "对方棋手的网络连接地址，如果还没有另一个棋手加入赛局，回车即可：\n"
	endif
	variable another_player_address = input(inputStr, "S")
	my_address = to_lowercase_string(trim(my_address))
	another_player_address = to_lowercase_string(trim(another_player_address))
	local_address = my_address
		
	start_cchess(protocol, local_address, another_player_address) 
	
	if get_country_language()[1] == "zh"
		print_line("本游戏是由MFP语言开发。MFP语言是一种非常容易上手的跨平台脚本编程语言。它的代码无需修改和编译，就可以在安卓和其他任意支持JAVA的个人电脑上运行。如果您对MFP编程语言感兴趣，请到百度手机或者酷安网下载MFP语言的IDE，可编程科学计算器，进行游戏开发。可编程科学计算器的安卓版自带运行于电脑上的MFP解释器，还可以创建APK安装包，真正实现电脑上编程调试，安卓上运行。还等什么，赶快试一下吧！")
	else
		print_line("This game was developed by MFP programming language. MFP is a very easy-to-learn and cross-platform scripting language for Android and any PC with JAVA support. You develop an MFP script on PC once and run it everywhere (including Android and PC with a different OS). If you are interested in it, please download MFP's ide, i.e. Scientific Calculator Plus, from Google Play at https://play.google.com/store/apps/details?id=com.cyzapps.AnMath . Scientific Calculator Plus can run on Android and PC and can build Android installation package (APK) from MFP scripts. You will enjoy the easy and quick game programming.")
	endif
endf 
 

endcs

