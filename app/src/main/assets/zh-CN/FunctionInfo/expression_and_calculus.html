<html>
<head>
<title>可编程科学计算器帮助</title>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8"></head>
<body style="background-color:white;">
<h2 style="color:blue">可编程科学计算器帮助：表达式和微积分函数</h2>
<table border="1" style="font-family:times;color:green;">
<tr>
<th>函数名</th>
<th>函数帮助信息</th>
</tr>
<tr>
<td><center>deri_ridders</center></td>
<td><p>::mfp::math::calculus::deri_ridders(4) :</p>
<p>deri_ridders(expr, var, val, ord)返回基于变量var的表达式expr在var等于val的时候的ord阶导数值。这个函数使用Ridders法进行计算。比如，deri_ridders("x**2+x","x",3,2)返回2。</p>
</td>
</tr>
<tr>
<td><center>derivative</center></td>
<td><p>::mfp::math::calculus::derivative(2) :</p>
<p>derivative(expression, variable)返回基于变量variable的表达式expression的导数表达式。注意expression和variable均为字符串。比如，derivative("x**2+x","x")返回一个字符串表达式"2*x+1"。</p>
<p>::mfp::math::calculus::derivative(4) :</p>
<p>derivative(expr, var, val, method)返回基于变量var的表达式expr在var等于val的时候的导数值。参数method用于选择计算方法，如果是true，意味着使用Ridders法进行计算，如果是false，则只是简单地计算导数表达式在val时候的值。比如，derivative("x**2+x","x",2,true)返回5。</p>
</td>
</tr>
<tr>
<td><center>evaluate</center></td>
<td><p>::mfp::statement::evaluate(1...) :</p>
<p>evaluate(expr_string,var_string1,var_value1,var_string2,var_value2, ...) 返回当基于字符串的变量var_string1等于var_value1，var_string2等于var_value2，...时，基于字符串的表达式expr_string的值。注意变量var_string1，var_string2，...的值可以为任意类型。变量的数目可以为0，也就是说，evaluate("3+2")是合法的。</p>
</td>
</tr>
<tr>
<td><center>expr_to_string</center></td>
<td><p>::mfp::statement::expr_to_string(1) :</p>
<p>expr_to_string(expr)将一个基于字符串的表达式expr转换成一个字符串。如果表达式中包含已经定义的函数，函数名将会被转换为全名，也就是绝对引用空间加函数名。比如expr_to_string("pwd()")将会返回"::mfp::io::file::pwd()"但是expr_to_string("pwd(1,  2)")将会返回"pwd(1,2)"，原因在于pwd函数没有参数，所以pwd()是合法的但是pwd(1,2)是调用一个没有定义的函数。</p>
</td>
</tr>
<tr>
<td><center>integrate</center></td>
<td><p>::mfp::math::calculus::integrate(2) :</p>
<p>integrate(x,y)返回基于变量y的表达式x的不定积分，表达式x和变量y均为字符串。注意如果表达式x不存在不定积分，或者x过于复杂无法解出其不定积分，本函数将会抛出异常。</p>
<p>::mfp::math::calculus::integrate(4) :</p>
<p>integrate(x,y,z,w)返回表达式x在变量y从z到w的积分值。表达式x和变量y均为字符串，z和w可以为实数，复数或字符串。注意本函数采用的积分算法是自适应Gauss-Kronrod积分法。</p>
<p>::mfp::math::calculus::integrate(5) :</p>
<p>integrate(x,y,z,w,v)返回表达式x相对于变量y从w到z的积分。计算时每一步步长为(w-z)/v。表达式x和变量y均为字符串，z和w可以为实数，复数或字符串，v必须为正整数。注意如果v是0，则相当于执行integrate(x,y,z,w)。</p>
</td>
</tr>
<tr>
<td><center>lim</center></td>
<td><p>::mfp::math::calculus::lim(3) :</p>
<p>lim(expr, var, dest_value)用于计算表达式expr在变量var趋近于dest_value时的值。expr和var必须为字符串，dest_value为表达式或者数值，可以基于字符串，也可以不基于字符串。比如，lim("1/x", "x", 0)或者lim("(x+2)/(x+3)","x","3+0")。注意这个函数还在开发中。</p>
</td>
</tr>
<tr>
<td><center>product_over</center></td>
<td><p>::mfp::math::stat_stoch::product_over(3) :</p>
<p>函数product_over(x, y, z)计算基于字符串的表达式x中的变量取值从整数y逐步变化到整数z的值的乘积。y和z必须是字符串的形式，其中，y必须写成一个赋值表达式，比如"a=10"，这里，a是变量名。一个函数的例子为product_over("x+1", "x=1", "10")。</p>
</td>
</tr>
<tr>
<td><center>sum_over</center></td>
<td><p>::mfp::math::stat_stoch::sum_over(3) :</p>
<p>函数sum_over(x, y, z)计算基于字符串的表达式x中的变量取值从整数y逐步变化到整数z的值的总合。y和z必须是字符串的形式，其中，y必须写成一个赋值表达式，比如"a=10"，这里，a是变量名。一个函数的例子为sum_over("x+1", "x=1", "10")。</p>
</td>
</tr>
</table>
</body>
</html>
