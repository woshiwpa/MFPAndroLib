<html>
<head>
<title>可编程科学计算器帮助</title>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8"></head>
<body style="background-color:white;">
<h2 style="color:blue">可编程科学计算器帮助:并行计算函数</h2>
<table border="1" style="font-family:times;color:green;">
<tr>
<th>函数名</th>
<th>函数帮助信息</th>
</tr>
<tr>
<td><center>accept</center></td>
<td><p>::mfp::paracomp::connect::accept(1) :</p>
<p>accept函数接收一个从远端到一个本地网络界面的连接请求然后返回接收端（也就是位于本地网络界面的）连接对象。它只有一个参数，也就是本地网络界面对象信息。网络界面对象信息通常是函数generate_interface的返回值。注意如果没有连接请求到来，该函数调用会阻塞当前线程。该函数的一个例子是accept(local_info)。</p>
</td>
</tr>
<tr>
<td><center>close_connection</center></td>
<td><p>::mfp::paracomp::connect::close_connection(1) :</p>
<p>close_connection关闭一个连接对象。它只有一个参数，就是connect函数，accept函数或者get_incoming_connect函数返回的连接对象。本函数的一个例子为close_connection(conn_obj)。</p>
</td>
</tr>
<tr>
<td><center>close_local</center></td>
<td><p>::mfp::paracomp::connect::close_local(1) :</p>
<p>close_local关闭一个本地网络界面。它只有一个参数，就是generate_interface函数返回的连接对象。本函数的一个例子为close_local(local_info)。</p>
</td>
</tr>
<tr>
<td><center>connect</center></td>
<td><p>::mfp::paracomp::connect::connect(3) :</p>
<p>connect(local_info, remote_info, not_reuse_exist)函数建立一条从local_info所定义的本地网络界面到remote_info所定义的远端网络界面的网络连接。参数local_info和remote_info均可通过调用generate_interface函数获得。第三个参数也就是not_reuse_exist是一个可以省略的布尔值，其缺省值为false。如果它是true，本函数会重用本地网络界面和远端网络界面之间已存在的网络连接（如果有的话）。注意网络连接是双向的。一个网络连接无论是从本地网络界面连接到远端网络界面还是反过来，都是可以被本函数重用的。但需要注意的是，对于TCPIP协议，在服务端重用一个连入的网络连接不是那么容易。原因有两个，第一，当客户端发起一个连接时，客户端所使用的IP端口是由操作系统而不是MFP语言决定的，然而，在服务端，如果想要找到一个连入的网络连接，客户端的地址必须完整而精确，也就是说客户端的IP端口必不可少；其次，如果客户端和服务端之间存在NAT层，服务端不可能知道位于NAT层内部客户端实际的IP地址和端口。在这种情况下，如果想要重用已有的反向网络连接，MFP语言需要分析从客户端发送到服务端的消息，读取消息的"TransConnectDestRemote"值。该值就是该网络连接的客户端的地址的精确完整信息，如果该连接基于TCPIP协议，该值就是客户端的IP地址加IP端口。注意如果NAT层存在的话，该地址是从服务端看到的客户端地址而并非NAT层内部客户端实际的地址。获取客户端详细地址后再将该地址作为一个参数传入generate_interface函数便可获取准确的远端网络界面的信息，也就是remote_info。connect函数返回一个字典对象，如果调用成功，其"CONNECT"关键字的值便是连接对象的详细信息；反之，如果调用失败，"CONNECT"的值则是NULL，而额外的"ERROR"关键字的值就是出错信息。</p>
</td>
</tr>
<tr>
<td><center>generate_interface</center></td>
<td><p>::mfp::paracomp::connect::generate_interface(2) :</p>
<p>generate_interface(protocol, address)返回一个本地interface对象的定义。它需要两个参数。第一个参数是基于字符串的通信协议名，比如"TCPIP"；第二个参数是基于字符串的地址，比如"10.32.202.78"。第二个参数是可选参数，缺省值为本机的localhost地址，比如，对于"TCPIP"协议，本机localhost地址是"127.0.0.1"。</p>
</td>
</tr>
<tr>
<td><center>get_all_connect_call_ids</center></td>
<td><p>::mfp::paracomp::connect::get_all_connect_call_ids(1...) :</p>
<p>get_all_connect_call_ids返回一个网络界面所有的连接id或者一个连接的所有call沙盒id。它有两种模式。第一种调用模式只有一个参数，为一个代表本地网络界面信息的对象。 该对象为generate_interface函数的返回值。在这种模式下，本函数的返回值为所有从连入和连出的网络连接的id数组。注意如果本地信息不合法，本函数将抛出异常。第二种调用模式有三个参数。第一个参数为一个代表本地网络界面信息的对象。 该对象为generate_interface函数的返回值。第二个参数为一个连接对象的id（如果该连接是从本地到远端的连出网络连接，该id是远端地址，如果是连入网络连接，该id可以通过调用get_call_info函数得到）。第三个参数是一个布尔值，如果是true，这个函数返回所有通过该连接的连入的call沙盒id的数组，否则，这个函数返回所有通过该连接的连出的call沙盒id的数组。注意如果本地信息不合法，本函数将抛出异常。如果连接id不存在，将返回NULL。本函数的一个例子是get_all_connect_call_ids(server_interface, connect_id, false)。</p>
</td>
</tr>
<tr>
<td><center>get_all_host_addresses</center></td>
<td><p>::mfp::paracomp::host::get_all_host_addresses(1) :</p>
<p>get_all_host_addresses(protocol_name)返回protocol_name协议在本机的所有界面的所有地址。参数protocol_name是可选的。如果没有给出protocol_name参数或者给出是一个空的字符串，本函数返回本机所有被支持的通信协议在本机所有界面的所有地址。本函数的一个例子是get_all_host_addresses("TCPIP")。</p>
</td>
</tr>
<tr>
<td><center>get_call_info</center></td>
<td><p>::mfp::paracomp::connect::get_call_info(0) :</p>
<p>本函数如果不是在一个call沙盒中被调用，将会返回NULL。否则本函数返回一个数组。数组的第一个元素是调用本函数的call沙盒的id。数组的第二个元素是调用本函数的call沙盒所在的连接的id，数组的第三个元素是存有本地信息的对象。</p>
</td>
</tr>
<tr>
<td><center>get_incoming_connect</center></td>
<td><p>::mfp::paracomp::connect::get_incoming_connect(2) :</p>
<p>get_incoming_connect函数返回一个从远端地址连入一个本地网络界面的网络连接对象，或者如果没有这样一个网络连接存在则返回null。这个函数接受两个参数。第一个参数为一个代表本地网络界面信息的对象。 该对象为generate_interface函数的返回值。第二个参数是远端，也就是网络连接发起端（或者说客户端）的地址。注意对于TCPIP协议，客户端的地址必须是包括IP地址和端口的完整地址。此外，如果在远端和本地之间存在NAT层，客户端地址必须是在本地看到的远端地址，也就是客户端在NAT层外侧的地址。本函数的一个例子是get_incoming_connect(local_interface, "192.168.1.100:53521")。</p>
</td>
</tr>
<tr>
<td><center>get_local_host_address</center></td>
<td><p>::mfp::paracomp::host::get_local_host_address(1) :</p>
<p>get_local_host_address(protocol_name)返回protocol_name协议在本机的localhost地址。本函数的一个例子是get_local_host_address("TCPIP")。</p>
</td>
</tr>
<tr>
<td><center>initialize_local</center></td>
<td><p>::mfp::paracomp::connect::initialize_local(2) :</p>
<p>initialize_local(local_info, settings)初始化一个本地interface对象。该对象由local_info定义（local_info是调用generate_interface的返回结果）。这个函数的第二个参数是本地网络界面的设置。这个参数现在还没有被使用，所以可以省略。本函数如果成功返回true，否则返回false。</p>
</td>
</tr>
<tr>
<td><center>listen</center></td>
<td><p>::mfp::paracomp::connect::listen(1) :</p>
<p>listen(local_info)在一个本地interface对象上侦听外部的连接请求。参数local_info是调用generate_interface函数的返回值。listen如果成功，返回true，否则返回false。</p>
</td>
</tr>
<tr>
<td><center>receive_sandbox_message</center></td>
<td><p>::mfp::paracomp::connect::receive_sandbox_message(1...) :</p>
<p>receive_sandbox_message函数返回沙盒或者MFP主进程发送的信息。发送者可能位于一个和本地有直接连接（这里指的是通过MFP的connect函数构成的连接）的远端MFP实例中（可能是一个call沙盒或者该MFP实例的主进程），也可能就是本地MFP实例的一个call沙盒或者该MFP实例的主进程。它有两种工作模式。第一种工作模式只有一个参数，也就是等待的时间。如果是0，则意味着没有等待，立即返回。如果队列中有消息，则返回队列中的第一个消息，否则，返回NULL。如果等待时间小于0，则意味着阻塞模式。也就是说如果队列中没有消息，函数将会阻塞。如果等待时间是正数，则代表等待的毫秒数。如果等待时间过去之后队列中仍然没有消息，则返回NULL。如果本函数是在沙盒中被调用，则必须采用第一种工作模式。第二种工作模式有两个参数。第一个参数为一个代表本地信息（也就是监听地址）的对象。它告诉本函数选择哪一个本地地址收取消息。该信息对象可由调用generate_interface函数返回得到。第二个参数则是等待时间，其具体意义参见第一种工作模式。如果本函数是在MFP主进程中被调用，则必须采用第二种工作模式。本函数如果返回一个合法的消息，该返回值则是一个基于数组的字典。其中，“InterfaceInfo”的字段是发送端的本地信息，包括协议和地址。如果发送端和接收端位于同一个MFP实例中，并且接收端是该MFP实例的一个call沙盒而发送端是该MFP实例的主进程，这个字段则为NULL。“ConnectId”的字段是发送端的连接ID，如果发送端是MFP实例的主进程，该字段为一个空字符串。“CallId”的字段是发送端的call沙盒ID，如果发送端是MFP实例的主进程，该字段为0。“TransConnectSrcLocal”字段是传输连接发送端自己看到的本地地址。这里，传输连接未必是发送或者接收端call沙盒的发起连接。但传输连接的两端必然分别位于发送端和接收端所在的MFP实例中。发送端，无论是call沙盒还是MFP主进程，将要发送的消息交给MFP实例，然后发送端MFP实例将该消息通过传输连接发送到接收端的MFP实例，再由接收端MFP实例将消息配送到目标沙盒或者MFP主进程。注意由于传输连接是双向的，发送端不一定是传输连接的客户端，相应地，接收端也不一定是传输连接的服务端。类似地，字段“TransConnectSrcRemote”是传输连接发送端看到的接收端地址；字段“TransConnectDestLocal”是传输连接接收端自己看到的本地地址；字段“TransConnectDestRemote”是传输连接接收端看到的发送端地址。通常情况下，字段“TransConnectSrcLocal”和“TransConnectDestRemote”的值应该是一致的，字段“TransConnectSrcRemote”和“TransConnectDestLocal”的值应该是一致的。但是，如果是TCPIP协议并且发送端和接收端之间存在NAT层，这些字段的值不见得会一致。如果接收端位于传输连接的服务端，“TransConnectDestRemote”字段的值会非常有用，因为它可以告诉MFP传输连接在服务端的id，只有知道id该连接才可以被重用，并且还可以通过该连接发送回复的消息。如果发送端和接收端位于同一个MFP实例中，则不需要通过传输连接发送消息，这种情况下上述4个字段的内容都是空字符串。最后，消息的“Message”的字段是消息的内容。本函数的两个例子为receive_sandbox_message(-1)和receive_sandbox_message(local_info, -1)。</p>
</td>
</tr>
<tr>
<td><center>send_sandbox_message</center></td>
<td><p>::mfp::paracomp::connect::send_sandbox_message(1...) :</p>
<p>send_sandbox_message函数将消息发送到沙盒或MFP主进程。它具有四种工作模式。第一种工作模式是从沙盒向其本地MFP主进程发送消息。在这种情况下，该功能只有一个参数，即消息内容。请注意，消息内容不必是字符串。例如，send_sandbox_message([1,2,3])从沙盒向本地MFP主进程发送[1,2,3]。第二种工作模式是将消息从MFP主进程或沙盒发送到本地沙盒。在这种情况下，该功能需要四个参数。第一个参数是本地信息对象。可以从generate_interface函数获得此本地信息对象。启动接收方沙盒的call请求被本地信息对象所代表的接口地址接受。第二个参数是接收方沙盒的连接ID。注意这个连接是启动接收方沙盒call对象的连接。第三个参数是接收方沙盒的call沙盒Id。最后一个参数是消息内容。此模式的一个示例是send_sandbox_message(local_info,"127.0.0.1",1,238.975+3.01i)。第三种工作模式是将消息从本地沙盒或MFP主进程发送到远端MFP主进程。请注意，本地MFP实例必须已经通过调用connect函数连接到远端MFP实例。此模式需要两个参数。第一个是从connect函数返回的连接对象（即返回值的“CONNECT”字段）。第二个参数是消息内容。一个示例是send_sandbox_message(conn1,"Hello!")。最后一种工作模式是将消息从本地沙盒或MFP主进程发送到远端沙盒。请注意，本地MFP实例必须通过调用connect函数连接到远端MFP实例。此模式需要五个参数。第一个参数是从连接函数返回的连接对象（即返回值的“CONNECT”字段）。第二个参数是从generate_interface函数获得的远程接口对象。此远程接口位于连接的另一端。远程接口接受了启动接收方沙盒的call请求。第三个参数是接收方沙盒的连接ID。注意这个连接是启动接收方沙盒call对象的连接。第四个参数是接收方沙盒的call沙盒ID。最后一个参数是消息内容。此模式的一个示例是send_sandbox_message(conn1,remote_info,"192.168.1.139",4,[[1,2],[3,4]])。</p>
</td>
</tr>
<tr>
<td><center>set_local_host_address</center></td>
<td><p>::mfp::paracomp::host::set_local_host_address(4) :</p>
<p>set_local_host_address函数用于设置所选通信协议的本地地址。它有四个参数。第一个参数是通信协议的的名字。当前只支持WEBRTC协议所以它只能是字符串"WEBRTC"。第二个参数是通信接口的名称，当前支持"main"作爲参数值。第三个参数是通信地址。由于仅支持WEBRTC协议，通信地址必须是一个合法的电子邮件地址。推荐使用微软的outlook邮件或者腾讯公司的QQ邮件。第四个参数是一个字符串数组。数组中的第一个元素为"0"，代表该email地址支持smtp和imap协议。数组中的第二个元素为电子邮件的密码。注意这是smtp和imap协议收发邮件所使用的密码，该密码未见得和登录网页信箱所需要的密码一样。如果开发人员使用微软的outlook邮件或者hotmail邮箱，或者谷歌的gmail，以及腾讯的QQ邮件，以上信息就足够了。但是，如果是其他的邮件地址，开发人员则需要提供smtp服务器和imap服务器的信息。这包括smtp服务器的地址，端口，是否支持SSL协议，和imap服务器的地址，端口，以及是否支持SSL协议。其中，是否支持SSL协议也是一个字符串，"0"表示不支持，"1"表示支持，"-1"表示不清楚。这些信息将分别填入第四个参数的第三号到第八号元素中。本函数的一个例子是set_local_host_address("WEBRTC", "main", "abcxyz@yahoo.com", ["0", "xxxxyyyyzzzzwwww", "smtp.mail.yahoo.com", "465", "1", "imap.mail.yahoo.com", "993", "1"])。另外一个例子是set_local_host_address("WEBRTC", "main", "mnopqrst@outlook.com", ["0", "abcd1234"])。</p>
</td>
</tr>
<tr>
<td><center>suspend_until_cond</center></td>
<td><p>::mfp::paracomp::threading::suspend_until_cond(4) :</p>
<p>此函数将挂起当前线程，直到满足特定条件为止。它有四个参数。第一个参数为变量名称。请注意，变量名不是字符串。第二个参数是布尔值。如果为TRUE，则该函数仅在写入变量的值（不必更改）之后才开始检查条件是否满足。否则，函数将在调用函数时立即检查是否满足条件。此参数是可选的。默认情况下为TRUE。第三个参数是运算符字符串。当前此参数仅支持以下值，即""，"=="，"!="，">"，"<"，">="和"<="。""表示如果变量值被写入（未必是被更改），则满足条件。其他运算符意味着使用运算符比较变量的值。如果比较返回TRUE，则满足条件。此参数也是可选的。默认情况下为""。最后一个参数是要比较的值。这也是一个可选参数。如果运算符为""，此参数没有任何作用。对于其他运算符，默认情况下，此参数的值为变量的当前值。例如，suspend_until_cond(a)等于调用suspend_until_cond(a,TRUE,"")，这意味着挂起当前线程，直到变量a被另一个线程写入。另一个示例是suspend_until_cond(a,FALSE,"!=")，这意味着挂起当前线程，直到变量a的值更改为止。第三个示例是suspend_until_cond(a,TRUE,">=",37)，这意味着挂起当前线程，直到写入变量a（不一定更改a的值），并且写入后的值不小于37。如果写入后的值无法和37进行比较，例如a新的值为"Hello"，则当前线程仍然被阻塞。</p>
</td>
</tr>
</table>
</body>
</html>
