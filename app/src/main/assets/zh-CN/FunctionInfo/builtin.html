<html>
<head>
<title>可编程科学计算器帮助</title>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8"></head>
<body style="background-color:white;">
<h2 style="color:blue">可编程科学计算器帮助：内置函数</h2>
<table border="1" style="font-family:times;color:green;">
<tr>
<th>函数名</th>
<th>函数帮助信息</th>
</tr>
<tr>
<td><center>abs</center></td>
<td><p>::mfp::math::complex::abs(1) :</p>
<p>abs(x)返回复数x的模或者实数x的绝对值。</p>
</td>
</tr>
<tr>
<td><center>accept</center></td>
<td><p>::mfp::paracomp::connect::accept(1) :</p>
<p>accept函数接收一个从远端到一个本地网络界面的连接请求然后返回接收端（也就是位于本地网络界面的）连接对象。它只有一个参数，也就是本地网络界面对象信息。网络界面对象信息通常是函数generate_interface的返回值。注意如果没有连接请求到来，该函数调用会阻塞当前线程。该函数的一个例子是accept(local_info)。</p>
</td>
</tr>
<tr>
<td><center>acos</center></td>
<td><p>::mfp::math::trigon::acos(1) :</p>
<p>acos(x)返回x的反余弦值，注意x可以为复数。</p>
</td>
</tr>
<tr>
<td><center>add_peer_stream</center></td>
<td><p>::mfp::multimedia::webrtc_lib::add_peer_stream(1) :</p>
<p>add_peer_stream函数将多媒体流（也就是视频和音频）链入web RTC的peer connection对象。注意此处的web RTC是指的用于支持声音和视频通信的web RTC函数库，而不是用于支持数据通信的WEBRTC协议栈。它只有一个参数，就是peer connection对象的Id，也就是peer connection对象连接的远端的地址。</p>
</td>
</tr>
<tr>
<td><center>add_rtc_media_ice_candidate</center></td>
<td><p>::mfp::multimedia::webrtc_lib::add_rtc_media_ice_candidate(2) :</p>
<p>add_rtc_media_ice_candidate函数将一个ICE协议候选对象加入到peer connection对象的ICE候选对象列表中。它有两个参数，第一个参数是peer connection对象的Id。第二个参数是基于字符串的ICE候选对象的内容。</p>
</td>
</tr>
<tr>
<td><center>add_rtc_video_output</center></td>
<td><p>::mfp::multimedia::webrtc_lib::add_rtc_video_output(5) :</p>
<p>add_rtc_video_output将一个RTC视频子窗口加到显示窗口上。它有五个参数，第一个参数是显示窗口的句柄，该句柄是open_screen_display函数的返回值。剩下的四个参数分别是基于整数的视频子窗口的左上顶点的横坐标，纵坐标，宽度和高度。这四个参数决定了视频子窗口在显示窗口上的位置。</p>
</td>
</tr>
<tr>
<td><center>alloc_array</center></td>
<td><p>::mfp::array::alloc_array(1...) :</p>
<p>alloc_array(x...)返回一个新分配的矩阵，其大小由参数决定。所有的参数都必须为正整数。</p>
<p>::mfp::array::alloc_array(2) :</p>
<p>alloc_array(x, y)返回一个新分配的矩阵，其大小由正整数数列参数x决定。参数y是矩阵中所有元素的初始值，注意y参数可省略，如果省略，所有元素被初始化为0。</p>
</td>
</tr>
<tr>
<td><center>and</center></td>
<td><p>::mfp::math::logic::and(1...) :</p>
<p>and(x...)接受不少于1个的任意个数的参数，返回这些参数的逻辑与值。如果某一个参数不是布尔类型，将会被自动转换为布尔类型。</p>
</td>
</tr>
<tr>
<td><center>angle</center></td>
<td><p>::mfp::math::complex::angle(1) :</p>
<p>angle(x)返回复数x基于弧度的幅角值。</p>
</td>
</tr>
<tr>
<td><center>append_elem_to_ablist</center></td>
<td><p>::mfp::data_struct::array_based::append_elem_to_ablist(2) :</p>
<p>append_elem_to_ablist(array_based_list, ref_of_elem)将ref_of_elem的引用添加到基于数组的序列array_based_list的尾部。它返回更新过的array_based_list。作为参数的array_based_list和返回值共享元素。</p>
</td>
</tr>
<tr>
<td><center>asin</center></td>
<td><p>::mfp::math::trigon::asin(1) :</p>
<p>asin(x)返回x的反正弦值，注意x可以为复数。</p>
</td>
</tr>
<tr>
<td><center>atan</center></td>
<td><p>::mfp::math::trigon::atan(1) :</p>
<p>atan(x)返回x的反正切值，注意x可以为复数。</p>
</td>
</tr>
<tr>
<td><center>calculate_text_boundary</center></td>
<td><p>::mfp::graph_lib::draw::calculate_text_boundary(4) :</p>
<p>calculate_text_boundary(display, string, text_origin, text_style)返回一个 文本块的边界长方形。边界长方形是一个4元素数组，第一个元素是左边界，第二个元素是上边界，第三个元素是宽度，第四个元素是高度。Calculate_text_boundary的第一个参数是display，它既可以是screen display，也可以是image display。第二个参数是文本块的文本，可以不止一行。第三个参数是文本块起始点的位置。这是一个两元素数组，第一个元素是起始点横坐标，第二个元素是起始点纵坐标。最后一个参数是可省略参数，用于定义文本的字体和大小。如果它被省略，则字体为系统缺省字体，大小为16。如果它不被省略，那么它必须是一个包含一个或者两个元素的数组。如果是一个元素的数组，那么该元素必须是一个正整数，代表字体的大小，而字体则为系统缺省字体。如果是包含两个元素的数组，那么第一个元素为字体的大小，第二个元素是基于字符串的字体的名字。一个本函数的例子为：calculate_text_boundary(display, txtStr, [108, 190], [27, "SimSun"])。</p>
</td>
</tr>
<tr>
<td><center>calculate_text_origin</center></td>
<td><p>::mfp::graph_lib::draw::calculate_text_origin(8) :</p>
<p>calculate_text_origin(display, string, boundary_rect_left_top, width, height, horAlign, verAlign, text_style)返回指定边界长方形和对齐方式的文本块的起始点。起始点是一个两元素（[x,y]）数组，将会被draw_text作为参数使用。Calculate_text_origin的第一个参数是display，它既可以是screen display，也可以是image display。第二个参数是文本块的文本，可以不止一行。第三个参数是边界长方形的左上角位置。这是一个两元素数组，第一个元素是左边界坐标，第二个元素是上边界坐标。第四个和第五个参数是边界长方形的宽度和高度。第六个参数是文本块的横向对齐方式。-1表示左对齐，0表示中对齐，1表示右对齐。第七个参数是文本块的纵向对齐方式。-1表示上对齐，0表示中对齐，1表示下对齐。最后一个参数是可省略参数，用于定义文本的字体和大小。如果它被省略，则字体为系统缺省字体，大小为16。如果它不被省略，那么它必须是一个包含一个或者两个元素的数组。如果是一个元素的数组，那么该元素必须是一个正整数，代表字体的大小，而字体则为系统缺省字体。如果是包含两个元素的数组，那么第一个元素为字体的大小，第二个元素是基于字符串的字体的名字。一个本函数的例子为：calculate_text_origin(display, "pei is " + peichoices[idx], [256, 72], peiBndrySize[0], peiBndrySize[1], horAlign, verAlign, [22])。</p>
</td>
</tr>
<tr>
<td><center>cd</center></td>
<td><p>::mfp::io::file::cd(1) :</p>
<p>change_dir(path)（别名cd(path)）将当前路径变为字符串路径path。如果成功，返回true，否则返回false。例子包括change_dir("D:\\Windows") (Windows)和cd("/") (Android)。</p>
</td>
</tr>
<tr>
<td><center>ceil</center></td>
<td><p>::mfp::math::number::ceil(1) :</p>
<p>ceil(x), x是浮点数，返回不小于x的最小整数。</p>
<p>::mfp::math::number::ceil(2) :</p>
<p>ceil(x,y)，x是浮点数，y是非负整数，返回不小于x的小数点后面保留y位有效数字的最小数值。</p>
</td>
</tr>
<tr>
<td><center>change_dir</center></td>
<td><p>::mfp::io::file::change_dir(1) :</p>
<p>change_dir(path)（别名cd(path)）将当前路径变为字符串路径path。如果成功，返回true，否则返回false。例子包括change_dir("D:\\Windows") (Windows)和cd("/") (Android)。</p>
</td>
</tr>
<tr>
<td><center>clear_oval</center></td>
<td><p>::mfp::graph_lib::draw::clear_oval(5) :</p>
<p>clear_oval(owner_info, display, left_top, width, height)为绘图事件调度器添加一个清除椭圆形的事件。在绘图事件调度器调用这个绘制事件时，该事件将在display上清除一个椭圆形。Clear_oval有5个参数。第一个参数是owner_info。Owner_info告诉绘图事件调度器谁拥有这个绘图事件。Owner_info可以是一个字符串，代表拥有者的名字，也可以是一个整数，代表拥有者的id，还可以是NULL，代表系统拥有该事件，更可以是一个包含两个元素的数组，其中第一个元素是一个代表拥有者名字的字符串，或者代表拥有者id的整数，或者代表系统的NULL，第二个元素是一个代表时标的浮点数，但要注意这里的时标不是真正的时标，该浮点数可以是任意值。该浮点数的值在清除本绘图事件时会发挥作用。第二个参数是display，它既可以是screen display，也可以是image display。第三个参数是包含两个元素的数组（[x,y]），表示该椭圆的包络长方形左上顶点的位置。第四个和第五个参数为该椭圆的包络长方形的长度和高度。Clear_oval的例子包括：clear_oval(["my draw", 0.381], d, [128, 45], 18, 30)以及clear_oval(NULL, d, [23, 111], 70, 19)。</p>
</td>
</tr>
<tr>
<td><center>clear_rect</center></td>
<td><p>::mfp::graph_lib::draw::clear_rect(5) :</p>
<p>clear_rect(owner_info, display, left_top, width, height)为绘图事件调度器添加一个清除长方形的事件。在绘图事件调度器调用这个绘制事件时，该事件将在display上清除一个长方形。Clear_rect有5个参数。第一个参数是owner_info。Owner_info告诉绘图事件调度器谁拥有这个绘图事件。Owner_info可以是一个字符串，代表拥有者的名字，也可以是一个整数，代表拥有者的id，还可以是NULL，代表系统拥有该事件，更可以是一个包含两个元素的数组，其中第一个元素是一个代表拥有者名字的字符串，或者代表拥有者id的整数，或者代表系统的NULL，第二个元素是一个代表时标的浮点数，但要注意这里的时标不是真正的时标，该浮点数可以是任意值。该浮点数的值在清除本绘图事件时会发挥作用。第二个参数是display，它既可以是screen display，也可以是image display。第三个参数是包含两个元素的数组（[x,y]），表示该长方形左上顶点的位置。第四个和第五个参数为长方形的长度和高度。Clear_rect的例子包括：clear_rect(["my draw", 0.381], d, [128, 45], 18, 30)以及clear_rect(NULL, d, [23, 111], 70, 19)。</p>
</td>
</tr>
<tr>
<td><center>clone</center></td>
<td><p>::mfp::object::clone(1) :</p>
<p>clone(source_value)复制输入参数source_value并返回source_value的拷贝。输入参数可以是任何数据类型，包括字符串，数，复数以及数组。比如，如果变量a等于[1,2]，用户执行语句variable b = clone(a)就会得的b等于[1,2]。但是这时候b和a是两个不同的数据。如果用户改变a的值，比如，设置a[0]等于3，a将会变成[3,2]但是b依然是[1，2]。</p>
</td>
</tr>
<tr>
<td><center>clone_image</center></td>
<td><p>::mfp::multimedia::image_lib::clone_image(7) :</p>
<p>clone_image(image_src, src_left, src_top, src_right, src_bottom, dest_width, dest_height)返回一个新的被包装过的JAVA图像对象。该图形对象的宽度为dest_width，高度为dest_height。这个被返回的图像是（被拉缩过的）原图像image_src的被选中的区块的拷贝。被选中的区块的左、上、右、下的坐标分别是src_left、src_top、src_right和src_bottom。注意src_left、src_top、src_right和src_botto是可选参数，它们的缺省值分别是0、0、image_src的宽度和image_src的高度。dest_width和dest_height也是可选参数。它们的缺省值分别是src_right - src_left以及src_bottom - src_top。本函数的一个例子为 clone_image(img_src, 0, 0, 100, 200, 50, 300)。</p>
</td>
</tr>
<tr>
<td><center>close_connection</center></td>
<td><p>::mfp::paracomp::connect::close_connection(1) :</p>
<p>close_connection关闭一个连接对象。它只有一个参数，就是connect函数，accept函数或者get_incoming_connect函数返回的连接对象。本函数的一个例子为close_connection(conn_obj)。</p>
</td>
</tr>
<tr>
<td><center>close_local</center></td>
<td><p>::mfp::paracomp::connect::close_local(1) :</p>
<p>close_local关闭一个本地网络界面。它只有一个参数，就是generate_interface函数返回的连接对象。本函数的一个例子为close_local(local_info)。</p>
</td>
</tr>
<tr>
<td><center>close_rtc_media_peer</center></td>
<td><p>::mfp::multimedia::webrtc_lib::close_rtc_media_peer(1) :</p>
<p>本函数关闭一个web RTC的peer connection对象。注意此处的web RTC是指的用于支持声音和视频通信的web RTC函数库，而不是用于支持数据通信的WEBRTC协议栈。本函数唯一的参数是peer connection对象的Id，也就是它的远端地址。</p>
</td>
</tr>
<tr>
<td><center>concat_ablists</center></td>
<td><p>::mfp::data_struct::array_based::concat_ablists(2) :</p>
<p>concat_ablists(list1, list2)将基于数组的序列list2并入基于数组的序列list1的尾部并返回合并后的基于数组的序列。作为参数的list1和list2和返回值共享元素。</p>
</td>
</tr>
<tr>
<td><center>connect</center></td>
<td><p>::mfp::paracomp::connect::connect(3) :</p>
<p>connect(local_info, remote_info, not_reuse_exist)函数建立一条从local_info所定义的本地网络界面到remote_info所定义的远端网络界面的网络连接。参数local_info和remote_info均可通过调用generate_interface函数获得。第三个参数也就是not_reuse_exist是一个可以省略的布尔值，其缺省值为false。如果它是true，本函数会重用本地网络界面和远端网络界面之间已存在的网络连接（如果有的话）。注意网络连接是双向的。一个网络连接无论是从本地网络界面连接到远端网络界面还是反过来，都是可以被本函数重用的。但需要注意的是，对于TCPIP协议，在服务端重用一个连入的网络连接不是那么容易。原因有两个，第一，当客户端发起一个连接时，客户端所使用的IP端口是由操作系统而不是MFP语言决定的，然而，在服务端，如果想要找到一个连入的网络连接，客户端的地址必须完整而精确，也就是说客户端的IP端口必不可少；其次，如果客户端和服务端之间存在NAT层，服务端不可能知道位于NAT层内部客户端实际的IP地址和端口。在这种情况下，如果想要重用已有的反向网络连接，MFP语言需要分析从客户端发送到服务端的消息，读取消息的"TransConnectDestRemote"值。该值就是该网络连接的客户端的地址的精确完整信息，如果该连接基于TCPIP协议，该值就是客户端的IP地址加IP端口。注意如果NAT层存在的话，该地址是从服务端看到的客户端地址而并非NAT层内部客户端实际的地址。获取客户端详细地址后再将该地址作为一个参数传入generate_interface函数便可获取准确的远端网络界面的信息，也就是remote_info。connect函数返回一个字典对象，如果调用成功，其"CONNECT"关键字的值便是连接对象的详细信息；反之，如果调用失败，"CONNECT"的值则是NULL，而额外的"ERROR"关键字的值就是出错信息。</p>
</td>
</tr>
<tr>
<td><center>conv_bin_to_dec</center></td>
<td><p>::mfp::math::number::conv_bin_to_dec(1) :</p>
<p>conv_bin_to_dec(x)将一个二进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个十进制的数值。</p>
</td>
</tr>
<tr>
<td><center>conv_bin_to_hex</center></td>
<td><p>::mfp::math::number::conv_bin_to_hex(1) :</p>
<p>conv_bin_to_hex(x)将一个二进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个代表16进制数的字符串。</p>
</td>
</tr>
<tr>
<td><center>conv_bin_to_oct</center></td>
<td><p>::mfp::math::number::conv_bin_to_oct(1) :</p>
<p>conv_bin_to_oct(x)将一个二进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个代表八进制数的字符串。</p>
</td>
</tr>
<tr>
<td><center>conv_dec_to_bin</center></td>
<td><p>::mfp::math::number::conv_dec_to_bin(1) :</p>
<p>conv_dec_to_bin(x)将一个十进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个代表二进制数的字符串。</p>
</td>
</tr>
<tr>
<td><center>conv_dec_to_hex</center></td>
<td><p>::mfp::math::number::conv_dec_to_hex(1) :</p>
<p>conv_dec_to_hex(x)将一个十进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个代表16进制数的字符串。</p>
</td>
</tr>
<tr>
<td><center>conv_dec_to_oct</center></td>
<td><p>::mfp::math::number::conv_dec_to_oct(1) :</p>
<p>conv_dec_to_oct(x)将一个十进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个代表八进制数的字符串。</p>
</td>
</tr>
<tr>
<td><center>conv_hex_to_bin</center></td>
<td><p>::mfp::math::number::conv_hex_to_bin(1) :</p>
<p>conv_hex_to_bin(x)将一个16进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个代表二进制数的字符串。</p>
</td>
</tr>
<tr>
<td><center>conv_hex_to_dec</center></td>
<td><p>::mfp::math::number::conv_hex_to_dec(1) :</p>
<p>conv_hex_to_dec(x)将一个16进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个十进制的数值。</p>
</td>
</tr>
<tr>
<td><center>conv_hex_to_oct</center></td>
<td><p>::mfp::math::number::conv_hex_to_oct(1) :</p>
<p>conv_hex_to_oct(x)将一个16进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个代表八进制数的字符串。</p>
</td>
</tr>
<tr>
<td><center>conv_ints_to_str</center></td>
<td><p>::mfp::string::conv_ints_to_str(1) :</p>
<p>conv_ints_to_str(int_or_array)将一个整数或者一组整数转换成一个Unicode字符串。如果只有一个整数，返回的字符串只包含一个Unicode字符，否则，返回字符串的字符数目和int_or_array中的元素数目一致。如果需要转换的整数是负数或者超出了Unicode字符集的定义范围，则被转换成整数0所对应的Unicode字符。示例包括conv_ints_to_str([20320, 22909, 25105, 22909, 22823, 23478, 22909])返回"你好我好大家好"，以及conv_ints_to_str(20320)返回"你"。</p>
</td>
</tr>
<tr>
<td><center>conv_oct_to_bin</center></td>
<td><p>::mfp::math::number::conv_oct_to_bin(1) :</p>
<p>conv_oct_to_bin(x)将一个八进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个代表二进制数的字符串。</p>
</td>
</tr>
<tr>
<td><center>conv_oct_to_dec</center></td>
<td><p>::mfp::math::number::conv_oct_to_dec(1) :</p>
<p>conv_oct_to_dec(x)将一个八进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个十进制的数值。</p>
</td>
</tr>
<tr>
<td><center>conv_oct_to_hex</center></td>
<td><p>::mfp::math::number::conv_oct_to_hex(1) :</p>
<p>conv_oct_to_hex(x)将一个八进制的非负数或代表该数的字符串x（x可以为浮点数，也可以为整数）转换为一个代表16进制数的字符串。</p>
</td>
</tr>
<tr>
<td><center>conv_str_to_ints</center></td>
<td><p>::mfp::string::conv_str_to_ints(1) :</p>
<p>conv_str_to_ints(str)将一个Unicode字符串转换成一个整数数组。通常，一个Unicode字符对应一个整数（但也有可能对应两个整数，如果该Unicode字符超出了UTF-16字符集的范围。但这种情况很少出现）。如果字符串是空的，则返回一个空数组。一个示例为conv_str_to_ints("你好我好大家好")返回[20320, 22909, 25105, 22909, 22823, 23478, 22909]。</p>
</td>
</tr>
<tr>
<td><center>copy_file</center></td>
<td><p>::mfp::io::file::copy_file(3) :</p>
<p>copy_file(source, destination, replace_exist)函数拷贝位于字符串source路径的文件或文件夹到位于字符串destination路径的文件或文件夹。如果第三个参数，replace_exist，是true，那么如果目标文件已经存在，它将会被源文件（或者源文件夹中的对应文件）替换。注意第三个参数可以省略，它的缺省值为false。 例子包括copy_file("c:\\temp\\try1", "D:\\", true) (Windows)和copy_file("/mnt/sdcard/testfile.txt", "./testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>copy_to_resource</center></td>
<td><p>::mfp_compiler::annotation::build_asset::copy_to_resource(2) :</p>
<p>copy_to_resource(source_path, destination_path)是一个用于编译的函数，也就是说它在打包脚本生成MFP应用时发挥作用。本函数source_path所指向的目标文件会被函数拷贝到assets目录下的destination_path所指向的文件。这样一来，一个从本脚本生成的MFP应用仍然能够在该应用的assets中找到程序中引用的图像或者声音文件。本函数返回一个包含三个元素的数组，第一个元素是一个字符串包含源文件路径，第二个是基于字符串的资源文件名，第三个是目标路径。</p>
</td>
</tr>
<tr>
<td><center>cos</center></td>
<td><p>::mfp::math::trigon::cos(1) :</p>
<p>cos(x)返回x的余弦值，注意x可以为复数。</p>
</td>
</tr>
<tr>
<td><center>create_abdict</center></td>
<td><p>::mfp::data_struct::array_based::create_abdict(0) :</p>
<p>create_abdict()创建一个新的，基于数组的字典。</p>
</td>
</tr>
<tr>
<td><center>create_file</center></td>
<td><p>::mfp::io::file::create_file(2) :</p>
<p>create_file(path, is_folder)创建一个文件（如果is_folder是false或者不存在）或者目录（如果if_folder是true）。如果这个基于字符串的路径path的上级目录不存在，不存在的上级目录将会被创建。如果文件能够被创建，这个函数返回true，否则返回false。例子包括create_file("c:\\temp\\try1", true) (Windows)和create_file("testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>create_image</center></td>
<td><p>::mfp::multimedia::image_lib::create_image(2) :</p>
<p>create_image(w, h)返回一个全新的，空白的被包装过的JAVA图像对象。该图形对象的宽度为w，高度为h。</p>
</td>
</tr>
<tr>
<td><center>create_rtc_media_answer</center></td>
<td><p>::mfp::multimedia::webrtc_lib::create_rtc_media_answer(5) :</p>
<p>本函数在接收到一个offer信令之后创建一个web RTC的answer信令。注意此处的web RTC是指的用于支持声音和视频通信的web RTC函数库，而不是用于支持数据通信的WEBRTC协议栈。本函数有5个参数。第一个是peer connection对象的id。第二个是SDP的类型。该参数应该就是一个"offer"字符串。第三个参数是SDP的内容，也就是offer信令的内容。第四个参数是强制性的限制参数集。最后一个参数是可选的限制参数集。最后一个参数可以省略。本函数的一个例子是create_rtc_media_answer(remoteAddr, sdpType, sdpContent, [["OfferToReceiveAudio", "true"], ["OfferToReceiveVideo", supportVideoStr]], [["DtlsSrtpKeyAgreement", "true"]])。</p>
</td>
</tr>
<tr>
<td><center>create_rtc_media_offer</center></td>
<td><p>::mfp::multimedia::webrtc_lib::create_rtc_media_offer(3) :</p>
<p>本函数创建一个web RTC的offer信令。注意此处的web RTC是指的用于支持声音和视频通信的web RTC函数库，而不是用于支持数据通信的WEBRTC协议栈。本函数有3个参数。第一个是peer connection对象的id。第二个参数是强制性的限制参数集。最后一个参数是可选的限制参数集。最后一个参数可以省略。本函数的一个例子是create_rtc_media_offer(remoteAddr, [["OfferToReceiveAudio", "true"], ["OfferToReceiveVideo", supportVideoStr]], [["DtlsSrtpKeyAgreement", "true"]])。</p>
</td>
</tr>
<tr>
<td><center>delete_file</center></td>
<td><p>::mfp::io::file::delete_file(2) :</p>
<p>delete_file(path, delete_children_in_folder)删除一个位于字符串path的文件或者目录。如果是一个目录且第二个参数delete_children_in_folder是true，目录中的所以文件和子目录将会被删除。注意第二个参数可以省略，它的缺省值是false。如果删除成功，本函数返回true，否则返回false。例子包括delete_file("c:\\temp\\try1", true) (Windows)和delete_file("testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>deri_ridders</center></td>
<td><p>::mfp::math::calculus::deri_ridders(4) :</p>
<p>deri_ridders(expr, var, val, ord)返回基于变量var的表达式expr在var等于val的时候的ord阶导数值。这个函数使用Ridders法进行计算。比如，deri_ridders("x**2+x","x",3,2)返回2。</p>
</td>
</tr>
<tr>
<td><center>derivative</center></td>
<td><p>::mfp::math::calculus::derivative(2) :</p>
<p>derivative(expression, variable)返回基于变量variable的表达式expression的导数表达式。注意expression和variable均为字符串。比如，derivative("x**2+x","x")返回一个字符串表达式"2*x+1"。</p>
<p>::mfp::math::calculus::derivative(4) :</p>
<p>derivative(expr, var, val, method)返回基于变量var的表达式expr在var等于val的时候的导数值。参数method用于选择计算方法，如果是true，意味着使用Ridders法进行计算，如果是false，则只是简单地计算导数表达式在val时候的值。比如，derivative("x**2+x","x",2,true)返回5。</p>
</td>
</tr>
<tr>
<td><center>det</center></td>
<td><p>::mfp::math::matrix::det(1) :</p>
<p>det(x)计算2维方阵x的行列式值。</p>
</td>
</tr>
<tr>
<td><center>deter</center></td>
<td><p>::mfp::math::matrix::deter(1) :</p>
<p>deter(x)计算2维方阵x的行列式值。</p>
</td>
</tr>
<tr>
<td><center>dir</center></td>
<td><p>::mfp::io::file::dir(1) :</p>
<p>print_file_list(path) (别名ls(path)或者dir(path))函数和Windows平台上的dir命令以及Linux平台上的ls命令类似。它打印出位于字符串path路径的文件或者目录中的所有子文件和子目录的信息。它返回打印的条目的个数。如果不存在一个文件或者目录对应于path路径，它返回-1。注意参数path是可以省略的。它的缺省值是当前目录。例子包括dir() (Windows)和ls("../testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>draw_image</center></td>
<td><p>::mfp::graph_lib::draw::draw_image(12) :</p>
<p>draw_image为绘图事件调度器添加一个绘制图像的事件。在绘图事件调度器调用这个绘制事件时，该事件将在display上绘制一个图像。Draw_image有两个不同的重载调用方式。第一个是draw_image(owner_info, display, image_or_path, left, top, width_ratio, height_ratio, painting_extra_info)。第二个是draw_image(owner_info, display, image_or_path, srcx1, srcy1, srcx2, srcy2, destx1, desty1, destx2, desty2, painting_extra_info)。在这两种不同的调用方式中，第一个参数是owner_info。Owner_info告诉绘图事件调度器谁拥有这个绘图事件。Owner_info可以是一个字符串，代表拥有者的名字，也可以是一个整数，代表拥有者的id，还可以是NULL，代表系统拥有该事件，更可以是一个包含两个元素的数组，其中第一个元素是一个代表拥有者名字的字符串，或者代表拥有者id的整数，或者代表系统的NULL，第二个元素是一个代表时标的浮点数，但要注意这里的时标不是真正的时标，该浮点数可以是任意值。该浮点数的值在清除本绘图事件时会发挥作用。第二个参数是display，它既可以是screen display，也可以是image display。第三个参数是图像的句柄或者是一个指向图像文件的地址字符串。最后一个参数是painting_extra_info，它告诉绘图事件调度器采用什么样的porterduff模式来绘制目标图像。这个参数是可选参数。porterduff模式内部机制比较复杂，建议开发者省略这个参数（也就是使用参数的缺省值）。如果开发者想要详细了解painting extra info，可以参考set_porterduff_mode以及get_porterduff_mode的函数帮助信息。如果开发者想要详细了解porterduff模式，建议阅读相关的JAVA文档。在第一种调用方式中，从第四个到第七个参数分别是图像将被绘制的位置的左边界的坐标，图像将被绘制的位置的上边界坐标，图像绘制时沿长度方向的缩放比例（是一个可以省略的参数，它的缺省值为1），以及图像绘制时沿高度方向的缩放比例（是一个可以省略的参数，它的缺省值为1）。在第二种调用方式中，从第四个到第十一个参数分别是选取图像将被绘制的部分的源长方形的左边界，选取图像将被绘制的部分的源长方形的上边界，选取图像将被绘制的部分的源长方形的右边界，选取图像将被绘制的部分的源长方形的下边界，目标位置的左边界，目标位置的上边界，目标位置的右边界以及目标位置的下边界。Draw_image的例子包括：draw_image("image", display, get_upper_level_path(get_src_file_path()) + "gem4.png", 48, 157) ，draw_image("image", display, gem3Img, 148, 257, 3, 0.5)以及draw_image("imagesrc", display, gem3Img, 0, 0, 32, 32, 210, 540, 300, 580, a_painting_extra_info)。</p>
</td>
</tr>
<tr>
<td><center>draw_line</center></td>
<td><p>::mfp::graph_lib::draw::draw_line(7) :</p>
<p>draw_line(owner_info, display, start_point_place, end_point_place, color, line_style, painting_extra_info)为绘图事件调度器添加一个绘制线段的事件。在绘图事件调度器调用这个绘制线段的事件时，该事件将在display上绘制一条线。Draw_line有7个参数。第一个参数是owner_info。Owner_info告诉绘图事件调度器谁拥有这个绘图事件。Owner_info可以是一个字符串，代表拥有者的名字，也可以是一个整数，代表拥有者的id，还可以是NULL，代表系统拥有该事件，更可以是一个包含两个元素的数组，其中第一个元素是一个代表拥有者名字的字符串，或者代表拥有者id的整数，或者代表系统的NULL，第二个元素是一个代表时标的浮点数，但要注意这里的时标不是真正的时标，该浮点数可以是任意值。该浮点数的值在清除本绘图事件时会发挥作用。第二个参数是display，它既可以是screen display，也可以是image display。第三个参数和第四个参数是线段的起始位置（[x1,y1]）和终止位置（[x2,y2]），它们均为包含两个元素的数组。第五个参数是color，代表绘制使用的颜色，它是一个4个或3个元素的数组，如果是4个元素，就是[Alpha，R，G，B]，如果是3个元素，就是[R，G，B]，在该数组中，每一个元素的值都是从0到255。第六个参数是line_style。在现阶段它是一个包含一个元素的数组，该元素是一个正整数，代表线的粗细。这个参数是可省略的，它的缺省值是[1]。最后一个参数是painting_extra_info，它告诉绘图事件调度器采用什么样的porterduff模式来绘制目标图像。这个参数也是可选参数。porterduff模式内部机制比较复杂，建议开发者省略这个参数（也就是使用参数的缺省值）。如果开发者想要详细了解painting extra info，可以参考set_porterduff_mode以及get_porterduff_mode的函数帮助信息。如果开发者想要详细了解porterduff模式，建议阅读相关的JAVA文档。</p>
<p>Draw_line的例子包括：draw_line(["my draw", 0.381], d, [128, 45], [250, -72], [79, 255, 0, 142])以及draw_line(NULL, d, [23, 111], [70, 333], [23, 178, 222], [7])。</p>
</td>
</tr>
<tr>
<td><center>draw_oval</center></td>
<td><p>::mfp::graph_lib::draw::draw_oval(8) :</p>
<p>draw_oval(owner_info, display, left_top, width, height, color, frame_or_fill, painting_extra_info)为绘图事件调度器添加一个绘制椭圆形的事件。在绘图事件调度器调用这个绘制事件时，该事件将在display上绘制一个椭圆形。Draw_oval有至少7个参数。第一个参数是owner_info。Owner_info告诉绘图事件调度器谁拥有这个绘图事件。Owner_info可以是一个字符串，代表拥有者的名字，也可以是一个整数，代表拥有者的id，还可以是NULL，代表系统拥有该事件，更可以是一个包含两个元素的数组，其中第一个元素是一个代表拥有者名字的字符串，或者代表拥有者id的整数，或者代表系统的NULL，第二个元素是一个代表时标的浮点数，但要注意这里的时标不是真正的时标，该浮点数可以是任意值。该浮点数的值在清除本绘图事件时会发挥作用。第二个参数是display，它既可以是screen display，也可以是image display。第三个参数是包含两个元素的数组（[x,y]），表示该椭圆的包络长方形左上顶点的位置。第四个和第五个参数为该椭圆的包络长方形的长度和高度。紧接着的参数是color，代表绘制使用的颜色，它是一个4个或3个元素的数组，如果是4个元素，就是[Alpha，R，G，B]，如果是3个元素，就是[R，G，B]，在该数组中，每一个元素的值都是从0到255。倒数第二个参数是是一个整数。它等于或小于零表示填充椭圆形，大于零表示椭圆形的边的宽度。最后一个参数是painting_extra_info，它告诉绘图事件调度器采用什么样的porterduff模式来绘制目标图像。这个参数是可选参数。porterduff模式内部机制比较复杂，建议开发者省略这个参数（也就是使用参数的缺省值）。如果开发者想要详细了解painting extra info，可以参考set_porterduff_mode以及get_porterduff_mode的函数帮助信息。如果开发者想要详细了解porterduff模式，建议阅读相关的JAVA文档。</p>
<p>Draw_oval的例子包括：draw_oval(["my draw", 0.381], d, [128, 45], 18, 30, [79, 255, 0, 142], 0)以及draw_oval(NULL, d, [23, 111], 70, 19, [23, 178, 222], 3)。</p>
</td>
</tr>
<tr>
<td><center>draw_point</center></td>
<td><p>::mfp::graph_lib::draw::draw_point(6) :</p>
<p>draw_point(owner_info, display, point_place, color, point_style, painting_extra_info)为绘图事件调度器添加一个绘制点的事件。在绘图事件调度器调用这个绘制点的事件时，该事件将在display上绘制一个点。Draw_point有六个参数。第一个参数是owner_info。Owner_info告诉绘图事件调度器谁拥有这个绘图事件。Owner_info可以是一个字符串，代表拥有者的名字，也可以是一个整数，代表拥有者的id，还可以是NULL，代表系统拥有该事件，更可以是一个包含两个元素的数组，其中第一个元素是一个代表拥有者名字的字符串，或者代表拥有者id的整数，或者代表系统的NULL，第二个元素是一个代表时标的浮点数，但要注意这里的时标不是真正的时标，该浮点数可以是任意值。该浮点数的值在清除本绘图事件时会发挥作用。第二个参数是display，它既可以是screen display，也可以是image display。第三个参数是point_place，也就是点的位置，他是一个包含两个元素的数组，也就是[x,y]。第四个参数color，代表点的颜色，它是一个4个或3个元素的数组，如果是4个元素，就是[Alpha，R，G，B]，如果是3个元素，就是[R，G，B]，在该数组中，每一个元素的值都是从0到255。第五个参数是point_style。在现阶段它的格式是[point_size, point_shape]。Point_size是点的大小。它是一个正整数。Point_shape是一个字符串，代表点的形状，可以取以下值："dot"（点，注意它的大小只能是1，point_size对它不起作用），"circle"（圆圈），"square"（方块），"diamond"（正菱形），"up_triangle"（尖朝上的三角形），"down_triangle"（尖朝下的三角形），"cross"（十字形）和"x"（叉号）。这个参数是可省略的，它的缺省值是[1, "dot"]。最后一个参数是painting_extra_info，它告诉绘图事件调度器采用什么样的porterduff模式来绘制目标图像。这个参数也是可选参数。porterduff模式内部机制比较复杂，建议开发者省略这个参数（也就是使用参数的缺省值）。如果开发者想要详细了解painting extra info，可以参考set_porterduff_mode以及get_porterduff_mode的函数帮助信息。如果开发者想要详细了解porterduff模式，建议阅读相关的JAVA文档。</p>
<p>Draw_point的例子包括：draw_point(["my draw", 0.381], d, [128, 45], [79, 255, 0, 142])以及draw_point(NULL, d, [23, 111], [23, 178, 222], [78, "square"])。</p>
</td>
</tr>
<tr>
<td><center>draw_polygon</center></td>
<td><p>::mfp::graph_lib::draw::draw_polygon(7...) :</p>
<p>draw_polygon(owner_info, display, point1_place, point2_place, point3_place, ..., color, frame_or_fill, painting_extra_info)为绘图事件调度器添加一个绘制多边形的事件。在绘图事件调度器调用这个绘制事件时，该事件将在display上绘制一个多边形。Draw_polygon有至少7个参数。第一个参数是owner_info。Owner_info告诉绘图事件调度器谁拥有这个绘图事件。Owner_info可以是一个字符串，代表拥有者的名字，也可以是一个整数，代表拥有者的id，还可以是NULL，代表系统拥有该事件，更可以是一个包含两个元素的数组，其中第一个元素是一个代表拥有者名字的字符串，或者代表拥有者id的整数，或者代表系统的NULL，第二个元素是一个代表时标的浮点数，但要注意这里的时标不是真正的时标，该浮点数可以是任意值。该浮点数的值在清除本绘图事件时会发挥作用。第二个参数是display，它既可以是screen display，也可以是image display。从第三个参数开始是多边形顶点的位置，它们均为包含两个元素的数组。紧接着的参数是color，代表绘制使用的颜色，它是一个4个或3个元素的数组，如果是4个元素，就是[Alpha，R，G，B]，如果是3个元素，就是[R，G，B]，在该数组中，每一个元素的值都是从0到255。倒数第二个参数是是一个整数。它等于或小于零表示填充多边形，大于零表示多边形的边的宽度。最后一个参数是painting_extra_info，它告诉绘图事件调度器采用什么样的porterduff模式来绘制目标图像。这个参数是可选参数。porterduff模式内部机制比较复杂，建议开发者省略这个参数（也就是使用参数的缺省值）。如果开发者想要详细了解painting extra info，可以参考set_porterduff_mode以及get_porterduff_mode的函数帮助信息。如果开发者想要详细了解porterduff模式，建议阅读相关的JAVA文档。</p>
<p>Draw_polygon的例子包括：draw_polygon(["my draw", 0.381], d, [128, 45], [250, -72], [338, 29], [79, 255, 0, 142], 0)以及draw_polygon(NULL, d, [23, 111], [70, 333], [-239, 89], [66, 183], [23, 178, 222], 3)。</p>
</td>
</tr>
<tr>
<td><center>draw_rect</center></td>
<td><p>::mfp::graph_lib::draw::draw_rect(8) :</p>
<p>draw_rect(owner_info, display, left_top, width, height, color, frame_or_fill, painting_extra_info)为绘图事件调度器添加一个绘制长方形的事件。在绘图事件调度器调用这个绘制事件时，该事件将在display上绘制一个长方形。Draw_rect有至少7个参数。第一个参数是owner_info。Owner_info告诉绘图事件调度器谁拥有这个绘图事件。Owner_info可以是一个字符串，代表拥有者的名字，也可以是一个整数，代表拥有者的id，还可以是NULL，代表系统拥有该事件，更可以是一个包含两个元素的数组，其中第一个元素是一个代表拥有者名字的字符串，或者代表拥有者id的整数，或者代表系统的NULL，第二个元素是一个代表时标的浮点数，但要注意这里的时标不是真正的时标，该浮点数可以是任意值。该浮点数的值在清除本绘图事件时会发挥作用。第二个参数是display，它既可以是screen display，也可以是image display。第三个参数是包含两个元素的数组（[x,y]），表示该长方形左上顶点的位置。第四个和第五个参数为长方形的长度和高度。紧接着的参数是color，代表绘制使用的颜色，它是一个4个或3个元素的数组，如果是4个元素，就是[Alpha，R，G，B]，如果是3个元素，就是[R，G，B]，在该数组中，每一个元素的值都是从0到255。倒数第二个参数是是一个整数。它等于或小于零表示填充长方形，大于零表示长方形的边的宽度。最后一个参数是painting_extra_info，它告诉绘图事件调度器采用什么样的porterduff模式来绘制目标图像。这个参数是可选参数。porterduff模式内部机制比较复杂，建议开发者省略这个参数（也就是使用参数的缺省值）。如果开发者想要详细了解painting extra info，可以参考set_porterduff_mode以及get_porterduff_mode的函数帮助信息。如果开发者想要详细了解porterduff模式，建议阅读相关的JAVA文档。</p>
<p>Draw_rect的例子包括：draw_rect(["my draw", 0.381], d, [128, 45], 18, 30, [79, 255, 0, 142], 0)以及draw_rect(NULL, d, [23, 111], 70, 19, [23, 178, 222], 3)。</p>
</td>
</tr>
<tr>
<td><center>draw_text</center></td>
<td><p>::mfp::graph_lib::draw::draw_text(7) :</p>
<p>draw_text(owner_info, display, string, origin_place, color, text_style, painting_extra_info)为绘图事件调度器添加一个绘制文本块的事件。在绘图事件调度器调用这个绘制事件时，该事件将在display上绘制一个文本块。Draw_text的第一个参数是owner_info。Owner_info告诉绘图事件调度器谁拥有这个绘图事件。Owner_info可以是一个字符串，代表拥有者的名字，也可以是一个整数，代表拥有者的id，还可以是NULL，代表系统拥有该事件，更可以是一个包含两个元素的数组，其中第一个元素是一个代表拥有者名字的字符串，或者代表拥有者id的整数，或者代表系统的NULL，第二个元素是一个代表时标的浮点数，但要注意这里的时标不是真正的时标，该浮点数可以是任意值。该浮点数的值在清除本绘图事件时会发挥作用。第二个参数是display，它既可以是screen display，也可以是image display。第三个参数是基于字符串的文本块，它可以多于一行。第四个参数是文本块起始点的位置。这是一个两元素数组，第一个元素是起始点横坐标，第二个元素是起始点纵坐标。第五个参数是color，代表绘制使用的颜色，它是一个4个或3个元素的数组，如果是4个元素，就是[Alpha，R，G，B]，如果是3个元素，就是[R，G，B]，在该数组中，每一个元素的值都是从0到255。第六个参数是可省略参数，用于定义文本的字体和大小。如果它被省略，则字体为系统缺省字体，大小为16。如果它不被省略，那么它必须是一个包含一个或者两个元素的数组。如果是一个元素的数组，那么该元素必须是一个正整数，代表字体的大小，而字体则为系统缺省字体。如果是包含两个元素的数组，那么第一个元素为字体的大小，第二个元素是基于字符串的字体的名字。最后一个参数是painting_extra_info，它告诉绘图事件调度器采用什么样的porterduff模式来绘制目标图像。这个参数是可选参数。porterduff模式内部机制比较复杂，建议开发者省略这个参数（也就是使用参数的缺省值）。如果开发者想要详细了解painting extra info，可以参考set_porterduff_mode以及get_porterduff_mode的函数帮助信息。如果开发者想要详细了解porterduff模式，建议阅读相关的JAVA文档。Draw_text的例子包括draw_text("image", display, txtStr, [108, 190], [255, 255, 255], [10 + idx, font])以及draw_text("image", display, txtStr, [108, 190], [255, 255, 255], [idx * 2])。</p>
</td>
</tr>
<tr>
<td><center>drop_old_painting_requests</center></td>
<td><p>::mfp::graph_lib::draw::drop_old_painting_requests(2) :</p>
<p>drop_old_painting_requests(owner_info, display)用于从screen或者image display的绘图事件调度器中移除一些绘图事件。移除的标准为，检查一个绘图事件的owner_info参数（也就是该事件的拥有者和创建时标），如果该绘图事件的拥有者和drop_old_painting_requests的拥有者完全一样，并且创建时标早于（小于）drop_old_painting_requests的创建时标，则该事件被移除。注意，有很多owner_info参数不包括创建时标，这种情况下创建时标为创建时的系统时间。本函数的例子为：drop_old_painting_requests("my owner", display)。该例子等价于drop_old_painting_requests(["my owner", now()], display)。</p>
</td>
</tr>
<tr>
<td><center>eig</center></td>
<td><p>::mfp::math::matrix::eig(1) :</p>
<p>eig(A)计算2维方阵A的特征向量和特征值。这个函数返回一个包含两个成员的列表。第一个成员是特征向量矩阵，每一列是一个特征向量。第二个成员是一个对角矩阵，每一个对角线元素是一个特征值。注意运算这个函数非常耗费内存和CPU资源，如果在手机上运行，矩阵A的尺寸最好不要超过6*6，如果在电脑上运行，最好不要超过8*8，否则可能造成内存不足而程序崩溃或者运行很长时间而没有结果。</p>
<p>::mfp::math::matrix::eig(2) :</p>
<p>eig(A, B)计算2维方阵A相对于同样尺寸的方阵B的特征向量和特征值，也就是Av = lambda * Bv，在这里，。lambda是一个特征值，v是一个特征向量。第二个参数，B，可以省略，其缺省值为I矩阵。这个函数返回一个包含两个成员的列表。第一个成员是特征向量矩阵，每一列是一个特征向量。第二个成员是一个对角矩阵，每一个对角线元素是一个特征值。注意运算这个函数非常耗费内存和CPU资源，如果在手机上运行，矩阵A的尺寸最好不要超过6*6，如果在电脑上运行，最好不要超过8*8，否则可能造成内存不足而程序崩溃或者运行很长时间而没有结果。</p>
</td>
</tr>
<tr>
<td><center>evaluate</center></td>
<td><p>::mfp::statement::evaluate(1...) :</p>
<p>evaluate(expr_string,var_string1,var_value1,var_string2,var_value2, ...) 返回当基于字符串的变量var_string1等于var_value1，var_string2等于var_value2，...时，基于字符串的表达式expr_string的值。注意变量var_string1，var_string2，...的值可以为任意类型。变量的数目可以为0，也就是说，evaluate("3+2")是合法的。</p>
</td>
</tr>
<tr>
<td><center>exp</center></td>
<td><p>::mfp::math::log_exp::exp(1) :</p>
<p>exp(x)返回自然对数e的x次方，x可以为实数或者虚数。</p>
</td>
</tr>
<tr>
<td><center>expr_to_string</center></td>
<td><p>::mfp::statement::expr_to_string(1) :</p>
<p>expr_to_string(expr)将一个基于字符串的表达式expr转换成一个字符串。如果表达式中包含已经定义的函数，函数名将会被转换为全名，也就是绝对引用空间加函数名。比如expr_to_string("pwd()")将会返回"::mfp::io::file::pwd()"但是expr_to_string("pwd(1,  2)")将会返回"pwd(1,2)"，原因在于pwd函数没有参数，所以pwd()是合法的但是pwd(1,2)是调用一个没有定义的函数。</p>
</td>
</tr>
<tr>
<td><center>eye</center></td>
<td><p>::mfp::math::matrix::eye(1) :</p>
<p>eye(x)返回正整数x乘x的2维方阵I。注意表达式eye(0)返回常数1。</p>
<p>::mfp::math::matrix::eye(2) :</p>
<p>eye(x,y)返回y（y为正整数）维方阵I，注意每一维长度均为正整数x。</p>
</td>
</tr>
<tr>
<td><center>fclose</center></td>
<td><p>::mfp::io::file::fclose(1) :</p>
<p>fclose(fd)关闭文件号fd所对应的文件。如果文件号不存在，返回-1，否则返回0。</p>
</td>
</tr>
<tr>
<td><center>feof</center></td>
<td><p>::mfp::io::file::feof(1) :</p>
<p>feof(fd)用于确定是否已经到达文件号为fd的读模式文件的末尾。如果是，返回true，否则返回false。如果文件号不合法，抛出异常。</p>
</td>
</tr>
<tr>
<td><center>floor</center></td>
<td><p>::mfp::math::number::floor(1) :</p>
<p>floor(x)，x是浮点数，返回不大于x的最大整数。</p>
<p>::mfp::math::number::floor(2) :</p>
<p>floor(x,y)，x是浮点数，y是非负整数，返回不大于x的小数点后面保留y位有效数字的最大数值。</p>
</td>
</tr>
<tr>
<td><center>fopen</center></td>
<td><p>::mfp::io::file::fopen(2) :</p>
<p>fopen(path, mode)打开位于path路径的文件并返回文件号以进行后续读写操作。它和C以及Matlab中的同名函数用法相似。但它仅支持"r"、"a"、"w"、"rb"、"ab"和"wb"六种读写模式。例子包括fopen("C:\\Temp\\Hello.dat", "ab") (Windows)和fopen("./hello.txt", "r") (Android)。</p>
<p>::mfp::io::file::fopen(3) :</p>
<p>fopen(path, mode, encoding)用字符编码encoding打开位于path路径的文件并返回文件号以进行后续读写操作。由于只有文本文件支持字符编码，参数mode只能为"r"、"a"和"w"3种读写模式。例子包括fopen("C:\\Temp\\Hello.txt", "a", "LATIN-1") (Windows)和fopen("./hello.txt", "r", "UTF-8") (Android)。</p>
</td>
</tr>
<tr>
<td><center>fprintf</center></td>
<td><p>::mfp::io::file::fprintf(2...) :</p>
<p>printf(format_string, ...)，sprintf(format_string, ...)和fprintf(fd, format_string, ...)和C/C++中的对应函数工作方式相似。这些函数通过format_string和其后的数值参数构造出一个新的字符串，printf函数将字符串打印到标准输出，sprintf函数将字符串作为返回值返回，fprintf函数则将字符串输出到文件号为fd的文本文件。字符串format_string支持输入整数（%d、%i、%x等），浮点数（%e、%f等），字符和字符串（%c和%s）等等。用户可以在C语言的帮助文档中找到format_string的构造方法。例如，printf("Hello world!%f", 3.14)将会打印输出"Hello world!3.140000"，而sprintf("%c%d", "A", 9)则返回"A9"（注意MFP不支持单一字符数据类型，所以单一的字符将会存储为一个只包括一个字符的字符串）。</p>
</td>
</tr>
<tr>
<td><center>fread</center></td>
<td><p>::mfp::io::file::fread(4) :</p>
<p>fread(fd, buffer, from, length)从文件（文件号fd）中读取length个字节数据，并把读出的数据保存在数组buffer中（从buffer的索引from开始保存）。注意from和length必须非负，并且from+length必须不比buffer的容量大。参数from和length可以同时省略。如果它们被省略，意味着fread读取整个buffer容量的字节数据并保存在整个buffer中。Buffer也可以省略，如果buffer省略，fread读取一个字节并返回。如果fread在读取之前发现已经到达文件末尾，则返回-1，否则返回读取字节的个数（如果buffer不省略）。如果文件不存在或非法或不可以访问，将会抛出异常。例子包括fread(1)、fread(2, byte_buffer)以及fread(2, byte_buffer, 3, 7)。</p>
</td>
</tr>
<tr>
<td><center>freadline</center></td>
<td><p>::mfp::io::file::freadline(1) :</p>
<p>freadline(fd)读取文本文件（文件号是fd）的一行。如果freadline在读取之前发现已经到达文件末尾，它返回NULL。否则，它返回基于字符串的这一行的内容，但不包括结尾的换行符。</p>
</td>
</tr>
<tr>
<td><center>fscanf</center></td>
<td><p>::mfp::io::file::fscanf(2) :</p>
<p>scanf(format_string)，sscanf(input_from, format_string)和fscanf(fd, format_string)和C/C++中的对应函数工作方式相似。scanf读取用户的一行输入，sscanf读取字符串input_from，fscanf从文件（文件号fd）中读取文件内容。字符串format_string支持输入整数（%d、%i、%x等），浮点数（%e、%f等），字符和字符串（%c和%s）等等。用户可以在C语言的帮助文档中找到format_string的构造方法。但是，和C语言有所不同，MFP中的这些函数不需要输入用于存储读取数值的参数。所有的读取的数值将会保存在一个数组中作为返回值返回。比如，sscanf("3Hello world!", "%d%c%c%s")将会返回[3, "H", "e", "llo"]（注意MFP不支持单一字符数据类型，所以单一的字符将会存储为一个只包括一个字符的字符串）。</p>
</td>
</tr>
<tr>
<td><center>fwrite</center></td>
<td><p>::mfp::io::file::fwrite(4) :</p>
<p>fwrite(fd, buffer, from, length)向文件（文件号fd）中写入length个字节数据。这些字节数据保存在数组buffer中（从buffer的索引from开始）。注意from和length必须非负，并且from+length必须不比buffer的容量大。参数from和length可以同时省略。如果它们被省略，意味着fwrite写入整个buffer的字节数据。Buffer也可以是一个单独的字节，在这种情况下fwrite仅写入一个字节的数据。如果文件不存在或非法或不可以访问，将会抛出异常。例子包括fwrite(1, 108)、fwrite(2, byte_buffer)以及fwrite(2, byte_buffer, 3, 7)。</p>
</td>
</tr>
<tr>
<td><center>generate_interface</center></td>
<td><p>::mfp::paracomp::connect::generate_interface(2) :</p>
<p>generate_interface(protocol, address)返回一个本地interface对象的定义。它需要两个参数。第一个参数是基于字符串的通信协议名，比如"TCPIP"；第二个参数是基于字符串的地址，比如"10.32.202.78"。第二个参数是可选参数，缺省值为本机的localhost地址，比如，对于"TCPIP"协议，本机localhost地址是"127.0.0.1"。</p>
</td>
</tr>
<tr>
<td><center>get_absolute_path</center></td>
<td><p>::mfp::io::file::get_absolute_path(1) :</p>
<p>get_absolute_path(fd_or_path)返回文件号fd_or_path（这里fd_or_path是一个整数）或者相对路径为fd_or_path（这里fd_or_path是一个字符串）所对应的文件的绝对路径字符串。</p>
</td>
</tr>
<tr>
<td><center>get_all_connect_call_ids</center></td>
<td><p>::mfp::paracomp::connect::get_all_connect_call_ids(1...) :</p>
<p>get_all_connect_call_ids返回一个网络界面所有的连接id或者一个连接的所有call沙盒id。它有两种模式。第一种调用模式只有一个参数，为一个代表本地网络界面信息的对象。 该对象为generate_interface函数的返回值。在这种模式下，本函数的返回值为所有从连入和连出的网络连接的id数组。注意如果本地信息不合法，本函数将抛出异常。第二种调用模式有三个参数。第一个参数为一个代表本地网络界面信息的对象。 该对象为generate_interface函数的返回值。第二个参数为一个连接对象的id（如果该连接是从本地到远端的连出网络连接，该id是远端地址，如果是连入网络连接，该id可以通过调用get_call_info函数得到）。第三个参数是一个布尔值，如果是true，这个函数返回所有通过该连接的连入的call沙盒id的数组，否则，这个函数返回所有通过该连接的连出的call沙盒id的数组。注意如果本地信息不合法，本函数将抛出异常。如果连接id不存在，将返回NULL。本函数的一个例子是get_all_connect_call_ids(server_interface, connect_id, false)。</p>
</td>
</tr>
<tr>
<td><center>get_all_host_addresses</center></td>
<td><p>::mfp::paracomp::host::get_all_host_addresses(1) :</p>
<p>get_all_host_addresses(protocol_name)返回protocol_name协议在本机的所有界面的所有地址。参数protocol_name是可选的。如果没有给出protocol_name参数或者给出是一个空的字符串，本函数返回本机所有被支持的通信协议在本机所有界面的所有地址。本函数的一个例子是get_all_host_addresses("TCPIP")。</p>
</td>
</tr>
<tr>
<td><center>get_all_referred_units</center></td>
<td><p>::mfp_compiler::annotation::compulsory_link::get_all_referred_units(0) :</p>
<p>get_all_referred_units()是一个用于编译的函数，也就是说它在打包脚本生成MFP应用时发挥作用。本函数返回一个数组，其中包括所有的用户定义的MFP函数和类的引用信息。</p>
</td>
</tr>
<tr>
<td><center>get_asset_file_path</center></td>
<td><p>::mfp::platform_hardware::platform_info::get_asset_file_path(1) :</p>
<p>get_asset_file_path(asset_file_entry)告诉开发人员一个asset文件（文件名由字符串参数asset_file_entry给出）的路径。注意，如果正在运行的脚本不是一个MFP应用，本函数返回null。</p>
</td>
</tr>
<tr>
<td><center>get_audio_track_enable</center></td>
<td><p>::mfp::multimedia::webrtc_lib::get_audio_track_enable(1) :</p>
<p>本函数测试音轨是否已经被激活。如果是，返回True，否则返回False。这个函数仅有一个参数，就是一个显示窗口的句柄。该句柄是open_screen_display函数的返回值。</p>
</td>
</tr>
<tr>
<td><center>get_call_info</center></td>
<td><p>::mfp::paracomp::connect::get_call_info(0) :</p>
<p>本函数如果不是在一个call沙盒中被调用，将会返回NULL。否则本函数返回一个数组。数组的第一个元素是调用本函数的call沙盒的id。数组的第二个元素是调用本函数的call沙盒所在的连接的id，数组的第三个元素是存有本地信息的对象。</p>
</td>
</tr>
<tr>
<td><center>get_canonical_path</center></td>
<td><p>::mfp::io::file::get_canonical_path(1) :</p>
<p>get_canonical_path(fd_or_path)返回文件号fd_or_path（这里fd_or_path是一个整数）或者相对路径为fd_or_path（这里fd_or_path是一个字符串）所对应的文件的标准路径（不依赖符号链接的绝对路径）字符串。</p>
</td>
</tr>
<tr>
<td><center>get_classes</center></td>
<td><p>::mfp_compiler::annotation::compulsory_link::get_classes(0...) :</p>
<p>get_classes(...) 是一个用于编译的函数，也就是说它在打包脚本生成MFP应用时发挥作用。本函数返回一个数组，其中包括所有的出现在参数中的MFP类的引用信息。</p>
</td>
</tr>
<tr>
<td><center>get_country_language</center></td>
<td><p>::mfp::platform_hardware::platform_info::get_country_language(0) :</p>
<p>本函数返回一个包含两个元素的矩阵。第一个元素是一个基于字符串的国家代码。国家代码要么是一个空字符串，要么是一个大写的，符合ISO 3166国际标准的两字母的代码，要么是一个符合UN M.49的3个数字的代码。用户可以查询百度百科获取ISO 3166国家代码的列表。第二个元素是基于字符串的语言代码。它基本上符合ISO 639国际标准，除了极少数例外。出现例外的原因是ISO 639标准在变化，一些语言的代码已经发生了改变，而这个函数总是返回旧的代码。用户可以查询百度百科获取ISO 639所有的语言代码列表。</p>
</td>
</tr>
<tr>
<td><center>get_day_of_month</center></td>
<td><p>::mfp::time_date::get_day_of_month(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分别返回时标timestamp所对应的年，月，本年中的第几天，本月中的第几天，本星期中的第几天（礼拜天是第0天，礼拜一是第一天，...），小时，分钟，秒钟和毫秒。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是礼拜天。</p>
</td>
</tr>
<tr>
<td><center>get_day_of_week</center></td>
<td><p>::mfp::time_date::get_day_of_week(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分别返回时标timestamp所对应的年，月，本年中的第几天，本月中的第几天，本星期中的第几天（礼拜天是第0天，礼拜一是第一天，...），小时，分钟，秒钟和毫秒。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是礼拜天。</p>
</td>
</tr>
<tr>
<td><center>get_day_of_year</center></td>
<td><p>::mfp::time_date::get_day_of_year(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分别返回时标timestamp所对应的年，月，本年中的第几天，本月中的第几天，本星期中的第几天（礼拜天是第0天，礼拜一是第一天，...），小时，分钟，秒钟和毫秒。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是礼拜天。</p>
</td>
</tr>
<tr>
<td><center>get_display_bgrnd_color</center></td>
<td><p>::mfp::graph_lib::display::get_display_bgrnd_color(1) :</p>
<p>get_display_bgrnd_color(display)返回一个display的背景色。该display既可以是screen display，也可以是image display。背景色是一个4个或3个元素的数组，如果是4个元素，就是[Alpha，R，G，B]，如果是3个元素，就是[R，G，B]，在该数组中，每一个元素的值都是从0到255。</p>
</td>
</tr>
<tr>
<td><center>get_display_bgrnd_image</center></td>
<td><p>::mfp::graph_lib::display::get_display_bgrnd_image(1) :</p>
<p>get_display_bgrnd_image(display)返回一个display的背景图像。</p>
</td>
</tr>
<tr>
<td><center>get_display_bgrnd_image_mode</center></td>
<td><p>::mfp::graph_lib::display::get_display_bgrnd_image_mode(1) :</p>
<p>get_display_bgrnd_image_mode(display)返回一个display的背景图像的布置方式。0表示原始背景图像被置于左上角，1表示背景图像被缩放值screen大小以便覆盖整个screen，2表示背景图像如贴瓷砖一样重复整齐排列，但每一片“瓷砖”大小保持原状， 3背景图像位于屏幕正中央。在这种情况下背景图像的大小也不会改变。</p>
</td>
</tr>
<tr>
<td><center>get_display_caption</center></td>
<td><p>::mfp::graph_lib::display::get_display_caption(1) :</p>
<p>get_display_caption(display)在JAVA平台上返回一个screen display的标题。对于image display，或者是对于安卓平台，get_display_caption总是返回空字符串。</p>
</td>
</tr>
<tr>
<td><center>get_display_confirm_close</center></td>
<td><p>::mfp::graph_lib::display::get_display_confirm_close(1) :</p>
<p>get_display_confirm_close(display)返回关闭一个screen display是否需要确认。对于image display，get_display_confirm_close总是返回FALSE。</p>
</td>
</tr>
<tr>
<td><center>get_display_orientation</center></td>
<td><p>::mfp::graph_lib::display::get_display_orientation(1) :</p>
<p>get_display_orientation(display)返回一个screen display是横屏（0）还是竖屏（1）还是横竖均可（-1）。对于image display，或者在JAVA平台上，get_display_orientation总是返回-1。</p>
</td>
</tr>
<tr>
<td><center>get_display_resizable</center></td>
<td><p>::mfp::graph_lib::display::get_display_resizable(1) :</p>
<p>get_display_resizable(display)用于返回一个布尔量，表示一个screen display是否可以改变大小。对于image display，get_display_resizable总是返回false。</p>
</td>
</tr>
<tr>
<td><center>get_display_size</center></td>
<td><p>::mfp::graph_lib::display::get_display_size(1) :</p>
<p>get_display_size(display)返回一个display（既可以是screen display，也可以是image display）的长度和高度。返回值是一个包含两个元素的矩阵，第一个元素是长度，第二个元素是高度。</p>
</td>
</tr>
<tr>
<td><center>get_display_snapshot</center></td>
<td><p>::mfp::graph_lib::display::get_display_snapshot(4) :</p>
<p>get_display_snapshot(display, update_screen_or_not, width_ratio, height_ratio)返回一个display（既可以是screen display，也可以是image display）的截屏。它的第二个参数，update_screen_or_not，告诉MFP在截屏之前该display是否需要刷新；它的第三个和第四个参数，是可选参数，缺省值均为1，分别用于告诉MFP返回的截屏的长度和高度的缩放比例。比如，get_display_snapshot(d, true, 0.5, 3)首先刷新屏幕d，然后截取d的图像，最后将截取的图像长度上压缩为原来的一半，高度上拉伸为原来的三倍并返回新的图像。</p>
</td>
</tr>
<tr>
<td><center>get_eigen_values</center></td>
<td><p>::mfp::math::matrix::get_eigen_values(1) :</p>
<p>get_eigen_values(A)计算2维方阵A的特征值。这个函数返回所有特征值，包括重复的特征值的列表。注意运算这个函数非常耗费内存和CPU资源，如果在手机上运行，矩阵A的尺寸最好不要超过6*6，如果在电脑上运行，最好不要超过8*8，否则可能造成内存不足而程序崩溃或者运行很长时间而没有结果。</p>
<p>::mfp::math::matrix::get_eigen_values(2) :</p>
<p>get_eigen_values(A, B)计算2维方阵A相对于同样尺寸的方阵B的特征值，也就是Av = lambda * Bv，在这里，。lambda是一个特征值，v是一个特征向量。第二个参数，B，可以省略，其缺省值为I矩阵。这个函数返回所有特征值，包括重复的特征值的列表。注意运算这个函数非常耗费内存和CPU资源，如果在手机上运行，矩阵A的尺寸最好不要超过6*6，如果在电脑上运行，最好不要超过8*8，否则可能造成内存不足而程序崩溃或者运行很长时间而没有结果。</p>
</td>
</tr>
<tr>
<td><center>get_elem_from_ablist</center></td>
<td><p>::mfp::data_struct::array_based::get_elem_from_ablist(2) :</p>
<p>get_elem_from_ablist(array_based_list, idx)返回基于数组的序列array_based_list在idx处的值的引用。如果idx不合法，一个异常将会被抛出。</p>
</td>
</tr>
<tr>
<td><center>get_event_info</center></td>
<td><p>::mfp::graph_lib::event::get_event_info(2) :</p>
<p>get_event_info(event, property_name)返回event事件的一个特性。它的第一个参数是事件，第二个参数是基于字符串的特性的名字。GDI_INITIALIZE和GDI_CLOSE事件没有单独的特性。WINDOW_RESIZED事件有四个整数特性，它们是"width"，"height"，"last_width"，"last_height"。它们分别表示当前窗口的宽度和高度，以及事件触发前窗口的宽度和高度。POINT_DOWN，POINT_UP和POINT_CLICKED事件均有三个特性。其中，"button"特性是一个整数，表示鼠标的哪一个键触发了这个事件。注意在安卓平台上，"button"特性总是0。"x"和"y"表示事件触发时的坐标位子，它们均为浮点数。POINT_DRAGGED和POINT_SLICED事件均有5个特性。其中，"button"特性是一个整数，表示鼠标的哪一个键触发了这个事件。注意在安卓平台上，"button"特性总是0。"last_x"和"last_y"表示事件触发前的坐标位子，它们均为浮点数。"x"和"y"表示事件触发后的坐标位子，它们均为浮点数。POINTER_PINCHED事件有八个特性，它们是"last_x"、"last_y"、"last_x2"、"last_y2"、"x"、"y"、"x2"以及"y2"。这些特性定义了参与POINTER_PINCHED事件的两根手指头在事件触发前和事件触发后的坐标位置。这些特性均为浮点数。</p>
</td>
</tr>
<tr>
<td><center>get_event_type</center></td>
<td><p>::mfp::graph_lib::event::get_event_type(1) :</p>
<p>get_event_type(event)返回一个整数，表示事件event的类型。在现阶段支持以下事件：GDI_INITIALIZE（类型为1，产生于screen display被创建的时候），GDI_CLOSE（类型为10，产生于screen display被关闭的时候），WINDOW_RESIZED（仅仅用于JAVA平台，类型为21，产生于screen display的窗口大小被调整的时候），POINTER_DOWN（类型为102，产生于鼠标按钮被按下或者用户手指点到触摸屏的时候），POINTER_UP（类型为103，产生于鼠标按钮弹起或者用户手指离开触摸屏的时候），POINTER_CLICKED（类型为104，产生于鼠标按钮快速按下再立即弹起或者用户手指轻敲触摸屏的时候），POINTER_DRAGGED（类型为105，产生于鼠标或者用户手指按下并拖动的时候。注意只要拖动还在进行中，这个事件就会连续地触发），POINTER_SLIDED（类型为106，产生于鼠标或者用户手指按下并拖动到终点，鼠标按钮弹起或者用户手指离开触摸屏的时候，注意这个事件只是在拖动事件结束的时候触发一次），POINTER_PINCHED（仅用于安卓平台，类型为201，当用户捏合手指进行类似缩放操作的时候触发）。</p>
</td>
</tr>
<tr>
<td><center>get_event_type_name</center></td>
<td><p>::mfp::graph_lib::event::get_event_type_name(1) :</p>
<p>get_event_type_name(event)返回一个字符串，表示事件event的类型的名字。在现阶段支持以下事件："GDI_INITIALIZE"（产生于screen display被创建的时候），"GDI_CLOSE"（产生于screen display被关闭的时候），"WINDOW_RESIZED"（仅仅用于JAVA平台，产生于screen display的窗口大小被调整的时候），"POINTER_DOWN"（产生于鼠标按钮被按下或者用户手指点到触摸屏的时候），"POINTER_UP"（产生于鼠标按钮弹起或者用户手指离开触摸屏的时候），"POINTER_CLICKED"（产生于鼠标按钮快速按下再立即弹起或者用户手指轻敲触摸屏的时候），"POINTER_DRAGGED"（产生于鼠标或者用户手指按下并拖动的时候。注意只要拖动还在进行中，这个事件就会连续地触发），"POINTER_SLIDED"（产生于鼠标或者用户手指按下并拖动到终点，鼠标按钮弹起或者用户手指离开触摸屏的时候，注意这个事件只是在拖动事件结束的时候触发一次），"POINTER_PINCHED"（仅用于安卓平台，当用户捏合手指进行类似缩放操作的时候触发）。</p>
</td>
</tr>
<tr>
<td><center>get_file_last_modified_time</center></td>
<td><p>::mfp::io::file::get_file_last_modified_time(1) :</p>
<p>get_file_last_modified_time(path)返回基于字符串路径的path的文件或目录的上一次更改时间。该时间等于从1970年1月1日午夜开始到上一次更改时刻所经历的毫秒数。如果path不存在或者没有访问权限，返回-1。</p>
</td>
</tr>
<tr>
<td><center>get_file_path</center></td>
<td><p>::mfp::io::file::get_file_path(1) :</p>
<p>get_file_path(fd)返回文件号fd（fd是一个整数）所对应的文件的路径字符串。</p>
</td>
</tr>
<tr>
<td><center>get_file_separator</center></td>
<td><p>::mfp::io::file::get_file_separator(0) :</p>
<p>get_file_separator()返回路径分割符。在Windows平台下返回字符串"\\"，在Linux和Android平台下返回字符串"/"。</p>
</td>
</tr>
<tr>
<td><center>get_file_size</center></td>
<td><p>::mfp::io::file::get_file_size(1) :</p>
<p>get_file_size(path)返回基于字符串路径的path的文件大小。如果path不是对应一个文件或者没有权限或者不存在，返回-1。</p>
</td>
</tr>
<tr>
<td><center>get_func_fullname</center></td>
<td><p>::mfp::reflection::get_func_fullname(3) :</p>
<p>get_func_fullname(function_name, number_of_params, citing_spaces_to_check)返回一个函数的全名（也就是引用空间加函数名）。它有三个参数。第一个参数是一个基于字符串的函数名，这个函数名可以包含部分或者不包含引用空间。第二个参数是参数的个数。这是一个可选参数，它的缺省值是-1，意思是仅仅搜索比较函数名，不考虑参数个数。第三个参数是将要检视的引用空间列表。这是一个基于数组的一维矩阵，比如["::mfp_compiler", "::mfp::*"]。在这个例子中，本函数将会首先搜索引用空间::mfp_compiler，然后搜索引用空间::mfp以及::mfp的所有子空间。这个参数也是可省略的。它的缺省值就是当前上下文所使用的引用空间。如果get_func_fullname需要寻找的函数在给出的引用空间中没有找到，本函数将会抛出异常。一个函数的例子为get_func_fullname("reflection:: get_func_fullname", 2)。这个例子的返回值为"::mfp::reflection::get_func_fullname"。注意这里参数的个数用的是2而不是3但依然合法，原因是get_func_fullname有两个缺省参数，所以参数个数可以是1或者2或者3。</p>
</td>
</tr>
<tr>
<td><center>get_functions</center></td>
<td><p>::mfp_compiler::annotation::compulsory_link::get_functions(0...) :</p>
<p>get_functions(...) 是一个用于编译的函数，也就是说它在打包脚本生成MFP应用时发挥作用。本函数返回一个数组，其中包括所有的出现在参数中的MFP函数的引用信息。</p>
</td>
</tr>
<tr>
<td><center>get_hour</center></td>
<td><p>::mfp::time_date::get_hour(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分别返回时标timestamp所对应的年，月，本年中的第几天，本月中的第几天，本星期中的第几天（礼拜天是第0天，礼拜一是第一天，...），小时，分钟，秒钟和毫秒。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是礼拜天。</p>
</td>
</tr>
<tr>
<td><center>get_image_size</center></td>
<td><p>::mfp::multimedia::image_lib::get_image_size(1) :</p>
<p>get_image_size(image_handle)返回由image_handle所代表的被包装过的JAVA图像对象的长和宽组成的数组。</p>
</td>
</tr>
<tr>
<td><center>get_incoming_connect</center></td>
<td><p>::mfp::paracomp::connect::get_incoming_connect(2) :</p>
<p>get_incoming_connect函数返回一个从远端地址连入一个本地网络界面的网络连接对象，或者如果没有这样一个网络连接存在则返回null。这个函数接受两个参数。第一个参数为一个代表本地网络界面信息的对象。 该对象为generate_interface函数的返回值。第二个参数是远端，也就是网络连接发起端（或者说客户端）的地址。注意对于TCPIP协议，客户端的地址必须是包括IP地址和端口的完整地址。此外，如果在远端和本地之间存在NAT层，客户端地址必须是在本地看到的远端地址，也就是客户端在NAT层外侧的地址。本函数的一个例子是get_incoming_connect(local_interface, "192.168.1.100:53521")。</p>
</td>
</tr>
<tr>
<td><center>get_json_field</center></td>
<td><p>::mfp::exdata::json::get_json_field(3) :</p>
<p>此函数从一个代表JSON数据的字符串中获取一个域的值。此函数有三个参数。第一个参数为一个代表JSON数据的字符串，第二个参数为JSON域的名字，第三个参数为JSON域的类型。如果第三个参数值为"s"，则意味着这个JSON域是一个字符串，如果是"b"，则意味着这个JSON域是一个布尔值，如果是"f"，则意味着这个JSON域是一个浮点数值，如果是"d"，则意味着这个JSON域是一个整数值，如果是"a"，则意味着这个JSON域是一个数组，如果是"j"，则意味着这个JSON域是一个代表JSON数据的字符串，如果是其他值或者这个参数被省略，则由MFP自己侦测这个JSON域的数据类型。注意第一个参数和第二个参数都是区分大小写的，但第三个参数不区分大小写。这个函数的返回值是这个JSON域的数据值。本函数的一个例子是get_json_field("{\"ABC\": null, \"JJJ\": {\"DEF\":[1, 8, [\"Welcome\", 9.99]],\"ZZ\":\"hello boy\"}}", "JJJ", "j")。</p>
</td>
</tr>
<tr>
<td><center>get_local_host_address</center></td>
<td><p>::mfp::paracomp::host::get_local_host_address(1) :</p>
<p>get_local_host_address(protocol_name)返回protocol_name协议在本机的localhost地址。本函数的一个例子是get_local_host_address("TCPIP")。</p>
</td>
</tr>
<tr>
<td><center>get_millisecond</center></td>
<td><p>::mfp::time_date::get_millisecond(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分别返回时标timestamp所对应的年，月，本年中的第几天，本月中的第几天，本星期中的第几天（礼拜天是第0天，礼拜一是第一天，...），小时，分钟，秒钟和毫秒。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是礼拜天。</p>
</td>
</tr>
<tr>
<td><center>get_minute</center></td>
<td><p>::mfp::time_date::get_minute(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分别返回时标timestamp所对应的年，月，本年中的第几天，本月中的第几天，本星期中的第几天（礼拜天是第0天，礼拜一是第一天，...），小时，分钟，秒钟和毫秒。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是礼拜天。</p>
</td>
</tr>
<tr>
<td><center>get_month</center></td>
<td><p>::mfp::time_date::get_month(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分别返回时标timestamp所对应的年，月，本年中的第几天，本月中的第几天，本星期中的第几天（礼拜天是第0天，礼拜一是第一天，...），小时，分钟，秒钟和毫秒。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是礼拜天。</p>
</td>
</tr>
<tr>
<td><center>get_num_of_results_sets</center></td>
<td><p>::mfp::math::polynomial::get_num_of_results_sets(1) :</p>
<p>get_num_of_results_sets(x)返回solve程序块返回值x中所包含的解集的组数。</p>
</td>
</tr>
<tr>
<td><center>get_porterduff_mode</center></td>
<td><p>::mfp::graph_lib::draw::get_porterduff_mode(1) :</p>
<p>get_porterduff_mode(painting_extra)返回一个painting extra数据结构的porterduff模式。painting extra数据结构在painting事件中被调用。Porterduff模式告诉MFP如何绘制目标区域。它是一个大写的字符串，具有以下可能值："CLEAR"，"SRC"，"DST"，"SRC_OVER"，"DST_OVER"，"SRC_IN"，"DST_IN"，"SRC_OUT"，"DST_OUT"，"SRC_ATOP"，"DST_ATOP"，"XOR"或者""，其中，空字符串""是缺省值。开发者可以参考JAVA文档以获取porterduff模式的详细信息。</p>
</td>
</tr>
<tr>
<td><center>get_rtc_video_output_count</center></td>
<td><p>::mfp::multimedia::webrtc_lib::get_rtc_video_output_count(1) :</p>
<p>本函数返回一个显示窗口上的RTC视频子窗口的个数。本函数仅有一个参数就是显示窗口的句柄。该句柄是open_screen_display函数的返回值。</p>
</td>
</tr>
<tr>
<td><center>get_rtc_video_output_lefttop</center></td>
<td><p>::mfp::multimedia::webrtc_lib::get_rtc_video_output_lefttop(2) :</p>
<p>本函数返回一个包含两个元素的数组。第一个元素是一个RTC视频输出子窗口的左上角的x坐标。第二个元素是该RTC视频输出子窗口的左上角的y坐标。这个函数有两个参数。第一个参数是一个显示窗口的句柄。该句柄是open_screen_display函数的返回值。第二个参数是该RTC视频输出子窗口在显示窗口的RTC视频输出子窗口序列中的索引。第一个RTC视频输出子窗口的索引是0，第二个RTC视频输出子窗口的索引是1，以此类推。</p>
</td>
</tr>
<tr>
<td><center>get_sandbox_session_lib_path</center></td>
<td><p>::mfp::platform_hardware::platform_info::get_sandbox_session_lib_path(0) :</p>
<p>函数get_sandbox_session_lib_path返回一个基于字符串的路径，该路径是当前沙盒的用户代码库的所在目录。沙盒是在服务端运行的一个线程。这个线程在服务端收到一个客户端的call指令后启动。这个客户端是一个独立于服务端的进程，它可能位于本机，也可能位于另外一台电脑。该线程拥有独立于服务端其它线程的MFP用户代码库，资源和栈。它的用户代码库,资源和栈是拷贝自发送call指令的客户端。这个函数没有参数。如果当前运行的代码不是位于沙盒中（比如，当前代码是在常规的命令提示符下运行），这个函数返回NULL 。</p>
</td>
</tr>
<tr>
<td><center>get_sandbox_session_resource_path</center></td>
<td><p>::mfp::platform_hardware::platform_info::get_sandbox_session_resource_path(0) :</p>
<p>函数get_sandbox_session_resource_path返回一个基于字符串的路径，该路径是当前沙盒的资源文件（比如图像文件，声音文件和数据库文件）的所在目录。沙盒是在服务端运行的一个线程。这个线程在服务端收到一个客户端的call指令后启动。这个客户端是一个独立于服务端的进程，它可能位于本机，也可能位于另外一台电脑。该线程拥有独立于服务端其它线程的MFP用户代码库，资源和栈。它的用户代码库,资源和栈是拷贝自发送call指令的客户端。这个函数没有参数。如果当前运行的代码不是位于沙盒中（比如，当前代码是在常规的命令提示符下运行），这个函数返回NULL 。</p>
</td>
</tr>
<tr>
<td><center>get_second</center></td>
<td><p>::mfp::time_date::get_second(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分别返回时标timestamp所对应的年，月，本年中的第几天，本月中的第几天，本星期中的第几天（礼拜天是第0天，礼拜一是第一天，...），小时，分钟，秒钟和毫秒。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是礼拜天。</p>
</td>
</tr>
<tr>
<td><center>get_solved_results_set</center></td>
<td><p>::mfp::math::polynomial::get_solved_results_set(2) :</p>
<p>get_solved_results_set(x, y)返回solve程序块返回值x中所包含的第y+1组解集。注意本函数返回一个一维数组，数组中的第一个元素是solve程序块的第一个待解变量的值，第二个元素是solve程序块的第二个待解变量的值，依次类推。</p>
</td>
</tr>
<tr>
<td><center>get_sound_path</center></td>
<td><p>::mfp::multimedia::audio_lib::get_sound_path(1) :</p>
<p>get_sound_path(sound_handle)返回sound_handle所指向的声音文件的路径。</p>
</td>
</tr>
<tr>
<td><center>get_sound_reference_path</center></td>
<td><p>::mfp::multimedia::audio_lib::get_sound_reference_path(1) :</p>
<p>get_sound_reference_path(sound_handle)返回sound_handle所指向的声音引用文件的路径。如果声音文件不是从zip压缩的读入的，声音引用文件和sound_handle所指向的声音文件（也就是get_sound_file函数的返回值）是同一个文件。如果声音文件是从zip压缩的读入的，声音引用文件路径是压缩文件的路径加上声音文件的压缩路径，比如"/folder1/folder2/snd.zip/zipped_folder/snd.wav"，这里"/folder1/folder2/snd.zip"是压缩文件路径，"zipped_folder/snd.wav"是声音文件的压缩路径。</p>
</td>
</tr>
<tr>
<td><center>get_sound_repeat</center></td>
<td><p>::mfp::multimedia::audio_lib::get_sound_repeat(1) :</p>
<p>get_sound_repeat(sound_handle)返回一个布尔量，表示参数sound_handle所代表的声音是否会被重复演奏。</p>
</td>
</tr>
<tr>
<td><center>get_sound_source_type</center></td>
<td><p>::mfp::multimedia::audio_lib::get_sound_source_type(1) :</p>
<p>get_sound_source_type(sound_handle)返回一个整数，代表sound_handle所指向的声音引用文件的类型。0表示常规文件，1表示压缩的zip文件，2表示引用于MFP App中安卓asset中的zip文件。</p>
</td>
</tr>
<tr>
<td><center>get_sound_volume</center></td>
<td><p>::mfp::multimedia::audio_lib::get_sound_volume(1) :</p>
<p>get_sound_volume(sound_handle)返回参数sound_handle所代表的声音的音量（一个变化范围从0到1的浮点数）。</p>
</td>
</tr>
<tr>
<td><center>get_src_file_path</center></td>
<td><p>::mfp::io::file::get_src_file_path(0) :</p>
<p>这个函数返回当前脚本的完整路径。当前脚本是调用get_src_file_path的脚本。如果本函数在命令提示符中被调用，则返回null。</p>
</td>
</tr>
<tr>
<td><center>get_time_stamp</center></td>
<td><p>::mfp::time_date::get_time_stamp(1...) :</p>
<p>get_time_stamp(string_or_year, ...)返回由其参数所决定的时标。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。这个函数有两种工作模式。第一种模式是get_time_stamp(string_time_stamp)。这种模式仅仅接受一个字符串参数，该参数必须基于yyyy-mm-dd hh:mm:ss[.f...]的格式。其中，秒的分数部分可以忽略。第二种模式是get_time_stamp(year, month, day, hour, minute, second, millisecond)。这些参数中，除了第一个参数year（年），所有的其他参数都可以省略。如果省略，month（月）和day（日）的缺省值是1，hour（小时），minute（分钟），second（秒）和millisecond（毫秒）的缺省值是0。比如get_time_stamp("1981-05-30 17:05:06")返回1981年5月30日17点5分6秒0毫秒的时标，用户也可以调用get_time_stamp(1981, 5, 30, 17, 5, 6, 0)获得同样的结果。</p>
</td>
</tr>
<tr>
<td><center>get_type_fullname</center></td>
<td><p>::mfp::reflection::get_type_fullname(1) :</p>
<p>get_type_fullname返回参数类型的全名，即带有引用空间路径的名称。例如，如果开发人员在引用空间::abc::def中定义了一个类A，并且已经从类A创建了一个名为objA的对象，则get_type_fullname(objA)将返回一个字符串，该字符串为::abc::def::a。请注意，由于MFP不区分大小写，并且内部所有变量名称和类型都转换为小写字母，所以A更改为a。另请注意，此函数可以返回MFP内置类型的全名。但是，建议用户仅在程序运行期间使用它来识别两个变量是否具有相同的类型。用户不能假定MFP内置类型的全名在以后的版本中永远不会更改。</p>
</td>
</tr>
<tr>
<td><center>get_upper_level_path</center></td>
<td><p>::mfp::io::file::get_upper_level_path(1) :</p>
<p>本函数返回参数字符串的上层目录（也是一个字符串）。比如，get_upper_level_path("abc/def")和get_upper_level_path("abc/def/")在安卓上都返回"abc/"。但是，要注意如果上层目录是非法目录，它返回null。比如get_upper_level_path("")和get_upper_level_path("/")均返回null。原因是""和"/"的上层目录均不存在。</p>
</td>
</tr>
<tr>
<td><center>get_value_from_abdict</center></td>
<td><p>::mfp::data_struct::array_based::get_value_from_abdict(2) :</p>
<p>get_value_from_abdict(array_based_dictionary, key)返回基于数组的字典array_based_dictionary的key所对应的值的引用。如果key不存在，一个异常将会被抛出。注意key只能是字符串。</p>
</td>
</tr>
<tr>
<td><center>get_variable_results</center></td>
<td><p>::mfp::math::polynomial::get_variable_results(2) :</p>
<p>get_variable_results(x, y)返回solve程序块返回值x中该solve程序块第y+1个待解变量的所有值。注意本函数返回一个一维数组，数组中的每一个元素是该待解变量的一个根。</p>
</td>
</tr>
<tr>
<td><center>get_video_track_enable</center></td>
<td><p>::mfp::multimedia::webrtc_lib::get_video_track_enable(1) :</p>
<p>本函数测试视频功能是否已经被激活。如果是，返回True，否则返回False。这个函数仅有一个参数，就是一个显示窗口的句柄。该句柄是open_screen_display函数的返回值。</p>
</td>
</tr>
<tr>
<td><center>get_working_dir</center></td>
<td><p>::mfp::io::file::get_working_dir(0) :</p>
<p>get_working_dir()（别名pwd()）返回基于字符串的当前路径。</p>
</td>
</tr>
<tr>
<td><center>get_year</center></td>
<td><p>::mfp::time_date::get_year(1) :</p>
<p>get_year(timestamp)，get_month(timestamp)，get_day_of_year(timestamp)，get_day_of_month(timestamp)，get_day_of_week(timestamp)，get_hour(timestamp)，get_minute(timestamp)，get_second(timestamp)和get_millisecond(timestamp) 分别返回时标timestamp所对应的年，月，本年中的第几天，本月中的第几天，本星期中的第几天（礼拜天是第0天，礼拜一是第一天，...），小时，分钟，秒钟和毫秒。时标是时标所表示的时刻和1970年1月1日午夜（UTC）的毫秒数时间差。例如，get_day_of_week(get_time_stamp(2014, 12, 21))返回0，表示2014年12月21日是礼拜天。</p>
</td>
</tr>
<tr>
<td><center>hash_code</center></td>
<td><p>::mfp::object::hash_code(1) :</p>
<p>hash_code函数返回它唯一一个参数的hash值。</p>
</td>
</tr>
<tr>
<td><center>iff</center></td>
<td><p>::mfp::command::iff(3...) :</p>
<p>函数iff(condition1, true_result1, condition2, true_result2, ..., false_result)的参数condition1，condition2，...为代表条件的布尔值，iff函数的返回值由条件值决定。比如，iff(true, 3, 2)返回3，iff(3<2, 3, 2)返回2（这是因为3<2是false），iff(3<2, 3, 5>4, 5, 6==9, 6, 9)返回5，以及iff(3<2, 3, 5<4, 5, 6==9, 6, 9)返回9。</p>
</td>
</tr>
<tr>
<td><center>image</center></td>
<td><p>::mfp::math::complex::image(1) :</p>
<p>image(x)返回复数x的虚部的实数值。</p>
<p>::mfp::math::complex::image(2) :</p>
<p>image(x, mode)返回复数x的虚部。如果参数mode是true，则返回虚数值，否则返回实数值。比如image(3+2i, true) = 2i而image(3+2i, false) = 2。</p>
</td>
</tr>
<tr>
<td><center>includes_inf</center></td>
<td><p>::mfp::array::includes_inf(1) :</p>
<p>includes_inf(x)用于判断参数x是否包含正负无穷。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_nan</center></td>
<td><p>::mfp::array::includes_nan(1) :</p>
<p>includes_nan(x)用于判断参数x是否包含Nan。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_nan_or_inf</center></td>
<td><p>::mfp::array::includes_nan_or_inf(1) :</p>
<p>includes_nan_or_inf(x)用于判断参数x是否包含Nan或者正负无穷。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_nan_or_inf_or_null</center></td>
<td><p>::mfp::array::includes_nan_or_inf_or_null(1) :</p>
<p>includes_nan_or_inf_or_null(x)用于判断参数x是否包含Nan或者正负无穷或者null。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_null</center></td>
<td><p>::mfp::array::includes_null(1) :</p>
<p>includes_null(x)用于判断参数x是否包含null。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>initialize_local</center></td>
<td><p>::mfp::paracomp::connect::initialize_local(2) :</p>
<p>initialize_local(local_info, settings)初始化一个本地interface对象。该对象由local_info定义（local_info是调用generate_interface的返回结果）。这个函数的第二个参数是本地网络界面的设置。这个参数现在还没有被使用，所以可以省略。本函数如果成功返回true，否则返回false。</p>
</td>
</tr>
<tr>
<td><center>initialize_rtc_mmedia</center></td>
<td><p>::mfp::multimedia::webrtc_lib::initialize_rtc_mmedia(0) :</p>
<p>本函数用于初始化web RTC库。注意此处的web RTC是指的用于支持声音和视频通信的web RTC函数库，而不是用于支持数据通信的WEBRTC协议栈。如果初始化成功，函数返回True，否则返回False。</p>
</td>
</tr>
<tr>
<td><center>input</center></td>
<td><p>::mfp::io::console::input(3) :</p>
<p>input(prompt,input_type,default_value)在命令控制台上打印出基于字符串的提示符prompt并等待用户输入。第二个参数input_type，以及第三个参数default_value，都是可选参数。在现阶段，如果第二个参数存在，并且它值是字符串"s"或者"S"，用户的输入将会被当作一个字符串并且函数将会返回这个字符串。如果第二个和第三个参数均存在，并且第二个参数是"default"或者"DEFAULT"，第三个参数将会作为缺省值。这个缺省值将在用户直接输入回车或者空格再回车的时候被函数作为返回值。除了前述这两种情况，本函数将把用户的输入看作是一个表达式，表达式的值作为返回值返回。如果用户输入不是一个合法的表达式，本函数会重新打印提示符要求用户再次输入。用户的一次输入由ENTER键结束。如果用户输入了多行，仅仅第一行会被读取。比如，用户运行input("$", "S")，然后在提示符后输入4 + 3，再按回车，这个函数返回一个字符串"4 + 3"，如果用户运行input("%")，然后再提示符后输入4 + 3，再按回车，这个函数返回7。如果用户运行input("#", "default", "e")，然后再提示符后输入空格并回车，本函数返回字符串"e"。</p>
</td>
</tr>
<tr>
<td><center>insert_elem_into_ablist</center></td>
<td><p>::mfp::data_struct::array_based::insert_elem_into_ablist(3) :</p>
<p>insert_elem_into_ablist(array_based_list, idx, ref_of_elem)将ref_of_elem的引用插入基于数组的序列array_based_list的idx号元素之前并返回更新后的基于数组的序列。作为参数的array_based_list和返回值共享元素。注意idx必须是一个合法的索引。</p>
</td>
</tr>
<tr>
<td><center>integrate</center></td>
<td><p>::mfp::math::calculus::integrate(2) :</p>
<p>integrate(x,y)返回基于变量y的表达式x的不定积分，表达式x和变量y均为字符串。注意如果表达式x不存在不定积分，或者x过于复杂无法解出其不定积分，本函数将会抛出异常。</p>
<p>::mfp::math::calculus::integrate(4) :</p>
<p>integrate(x,y,z,w)返回表达式x在变量y从z到w的积分值。表达式x和变量y均为字符串，z和w可以为实数，复数或字符串。注意本函数采用的积分算法是自适应Gauss-Kronrod积分法。</p>
<p>::mfp::math::calculus::integrate(5) :</p>
<p>integrate(x,y,z,w,v)返回表达式x相对于变量y从w到z的积分。计算时每一步步长为(w-z)/v。表达式x和变量y均为字符串，z和w可以为实数，复数或字符串，v必须为正整数。注意如果v是0，则相当于执行integrate(x,y,z,w)。</p>
</td>
</tr>
<tr>
<td><center>invert</center></td>
<td><p>::mfp::math::matrix::invert(1) :</p>
<p>invert(x)返回方块2维矩阵x的逆矩阵，注意x中的元素可以为复数。</p>
</td>
</tr>
<tr>
<td><center>is_directory</center></td>
<td><p>::mfp::io::file::is_directory(1) :</p>
<p>is_directory(path)用于判断位于字符串path的文件（或者目录）是否是一个目录。如果该文件或目录存在并且是一个目录返回true，否则返回false。例子包括is_directory("E:\\") (Windows)和is_directory("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_display_on_live</center></td>
<td><p>::mfp::graph_lib::display::is_display_on_live(1) :</p>
<p>is_display_on_live(display)函数返回布尔值，表示参数display是否依然有效。display既可以是screen display，也可以是image display。</p>
</td>
</tr>
<tr>
<td><center>is_eye</center></td>
<td><p>::mfp::math::matrix::is_eye(2) :</p>
<p>is_eye(x,y)用于确定数组（或数）x是否是单位阵I（或数字1），如果是，返回true，否则返回false。参数y是布尔量，可以省略，缺省值为false。如果y是true，将所有的null值视为0，否则，null值不被当作0。</p>
</td>
</tr>
<tr>
<td><center>is_file_executable</center></td>
<td><p>::mfp::io::file::is_file_executable(1) :</p>
<p>is_file_executable(path)用于判断位于字符串path的文件（或者目录）是否可执行。如果该文件或目录存在并且可执行返回true，否则返回false。例子包括is_file_executable("E:\\") (Windows)和is_file_executable("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_existing</center></td>
<td><p>::mfp::io::file::is_file_existing(1) :</p>
<p>is_file_existing(path)用于判断位于字符串path的文件（或者目录）是否存在。如果存在返回true，否则返回false。例子包括is_file_existing("E:\\") (Windows)和is_file_existing("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_hidden</center></td>
<td><p>::mfp::io::file::is_file_hidden(1) :</p>
<p>is_file_hidden(path)用于判断位于字符串path的文件（或者目录）是否隐藏。如果该文件或目录存在并且隐藏返回true，否则返回false。例子包括is_file_hidden("E:\\") (Windows)和is_file_hidden("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_normal</center></td>
<td><p>::mfp::io::file::is_file_normal(1) :</p>
<p>is_file_normal(path)用于判断位于字符串path的文件（或者目录）是否是一个常规文件而不是目录。如果该文件或目录存在并且是一个常规文件而不是目录返回true，否则返回false。例子包括is_file_normal("E:\\") (Windows)和is_file_normal("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_readable</center></td>
<td><p>::mfp::io::file::is_file_readable(1) :</p>
<p>is_file_readable(path)用于判断位于字符串path的文件（或者目录）是否可读。如果该文件或目录存在并且可读返回true，否则返回false。例子包括is_file_readable("E:\\") (Windows)和is_file_readable("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_file_writable</center></td>
<td><p>::mfp::io::file::is_file_writable(1) :</p>
<p>is_file_writable(path)用于判断位于字符串path的文件（或者目录）是否可写。如果该文件或目录存在并且可写返回true，否则返回false。例子包括is_file_writable("E:\\") (Windows)和is_file_writable("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_inf</center></td>
<td><p>::mfp::math::number::is_inf(1) :</p>
<p>is_inf(x)用于判断参数x是否为正负无穷。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>is_mfp_app</center></td>
<td><p>::mfp::platform_hardware::platform_info::is_mfp_app(0) :</p>
<p>is_running_on_android()告诉开发人员脚本是否在MFP应用中运行，如果是，返回true，如果不是，返回false。</p>
</td>
</tr>
<tr>
<td><center>is_nan_or_inf</center></td>
<td><p>::mfp::math::number::is_nan_or_inf(1) :</p>
<p>is_nan_or_inf(x)用于判断参数x是否为Nan或者正负无穷。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>is_nan_or_inf_or_null</center></td>
<td><p>::mfp::math::number::is_nan_or_inf_or_null(1) :</p>
<p>is_nan_or_inf_or_null(x)用于判断参数x是否为Nan或者正负无穷或者null。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>is_path_absolute</center></td>
<td><p>::mfp::io::file::is_path_absolute(1) :</p>
<p>is_path_absolute(path)用于判断位于字符串path是否是一个绝对路径（也就是不是相对于当前目录的路径）。如果是返回true，否则返回false。例子包括is_path_absolute("E:\\temp") (Windows)和is_path_absolute("Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_path_parent</center></td>
<td><p>::mfp::io::file::is_path_parent(2) :</p>
<p>is_path_parent(path1, path2)用于判断位于字符串path1是否是字符串path2的上级目录。如果是返回true，否则返回false。例子包括is_path_parent("E:\\temp", "E:\\temp\\..\\temp\\test") (Windows)和is_path_parent(".", "Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_path_same</center></td>
<td><p>::mfp::io::file::is_path_same(2) :</p>
<p>is_path_same(path1, path2)用于判断位于字符串path1是否和字符串path2指向同一条路径。如果是返回true，否则返回false。例子包括is_path_same("E:\\temp", "E:\\temp\\..\\temp\\") (Windows)和is_path_parent("/home/tony/Documents", "Documents/") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_playing</center></td>
<td><p>::mfp::multimedia::audio_lib::is_playing(1) :</p>
<p>这个函数接受一个媒体播放器句柄作为参数。如果该媒体播放器正在播放音乐，这个函数返回true，如果该媒体播放器没有正在播放，或者该句柄无效，这个函数返回false。</p>
</td>
</tr>
<tr>
<td><center>is_running_on_android</center></td>
<td><p>::mfp::platform_hardware::platform_info::is_running_on_android(0) :</p>
<p>is_running_on_android()告诉开发人员脚本是否在安卓平台上运行，如果是，返回true，如果不是，而是在普通的JAVA平台上运行，返回false。</p>
</td>
</tr>
<tr>
<td><center>is_sandbox_session</center></td>
<td><p>::mfp::platform_hardware::platform_info::is_sandbox_session(0) :</p>
<p>函数is_sandbox_session告诉开发者当前的MFP代码是否运行在一个沙盒中。沙盒是在服务端运行的一个线程。这个线程在服务端收到一个客户端的call指令后启动。这个客户端是一个独立于服务端的进程，它可能位于本机，也可能位于另外一台电脑。该线程拥有独立于服务端其它线程的MFP用户代码库,资源和栈。它的用户代码库,资源和栈是拷贝自发送call指令的客户端。这个函数没有参数，如果当前代码位于一个沙盒中它返回True，否则返回False 。</p>
</td>
</tr>
<tr>
<td><center>is_symbol_link</center></td>
<td><p>::mfp::io::file::is_symbol_link(1) :</p>
<p>is_symbol_link(path)用于判断位于字符串path的文件（或者目录）是否是一个符号链接。如果该文件或目录存在并且是一个符号链接返回true，否则返回false。例子包括is_symbol_link("E:\\") (Windows)和is_symbol_link("/home/tony/Documents/cv.pdf") (Android)。</p>
</td>
</tr>
<tr>
<td><center>is_valid_image_handle</center></td>
<td><p>::mfp::multimedia::image_lib::is_valid_image_handle(1) :</p>
<p>is_valid_image_handle(image_handle)返回一个布尔量，用于告诉开发人员一个被包装过的JAVA图像对象，也就是image_handle参数，是否依然合法还是已经被关闭。</p>
</td>
</tr>
<tr>
<td><center>is_zeros</center></td>
<td><p>::mfp::math::matrix::is_zeros(2) :</p>
<p>is_zeros(x,y)用于确定数组（或数）x是否是零矩阵（或数字0），如果是，返回true，否则返回false。参数y是布尔量，可以省略，缺省值为false。如果y是true，将所有的null值视为0，否则，null值不被当作0。</p>
</td>
</tr>
<tr>
<td><center>left_recip</center></td>
<td><p>::mfp::math::matrix::left_recip(1) :</p>
<p>left_recip(x)计算x的左除倒数，注意当前仅支持数值或二维矩阵。</p>
</td>
</tr>
<tr>
<td><center>lim</center></td>
<td><p>::mfp::math::calculus::lim(3) :</p>
<p>lim(expr, var, dest_value)用于计算表达式expr在变量var趋近于dest_value时的值。expr和var必须为字符串，dest_value为表达式或者数值，可以基于字符串，也可以不基于字符串。比如，lim("1/x", "x", 0)或者lim("(x+2)/(x+3)","x","3+0")。注意这个函数还在开发中。</p>
</td>
</tr>
<tr>
<td><center>link_video_stream</center></td>
<td><p>::mfp::multimedia::webrtc_lib::link_video_stream(4) :</p>
<p>此函数将web RTC视频流链接到一个RTC视频输出窗口。它有四个参数。第一个是显示窗口句柄，该句柄可以从open_screen_display函数调用中返回。第二个是peer connection对象的Id。第三个是视频流轨的ID。最后一个是RTC视频输出子窗口在显示窗口的RTC视频输出子窗口序列中的索引。此函数不会返回任何值。如果任何参数无效，或者无法将视频流链接到视频输出窗口，本函数会抛出一个异常。</p>
</td>
</tr>
<tr>
<td><center>list_files</center></td>
<td><p>::mfp::io::file::list_files(1) :</p>
<p>list_files(path)返回位于字符串path路径的目录中的所有子文件或者子目录的名字，或者如果path路径对应的是一个文件，它返回该文件的文件名。如果不存在一个文件或者目录对应于path路径，它返回NULL。注意参数path是可以省略的。它的缺省值是当前目录。例子包括list_files("c:\\temp\\try1") (Windows)和list_files("../testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>listen</center></td>
<td><p>::mfp::paracomp::connect::listen(1) :</p>
<p>listen(local_info)在一个本地interface对象上侦听外部的连接请求。参数local_info是调用generate_interface函数的返回值。listen如果成功，返回true，否则返回false。</p>
</td>
</tr>
<tr>
<td><center>load_image</center></td>
<td><p>::mfp::multimedia::image_lib::load_image(1) :</p>
<p>load_image(image_path)返回一个被包装过的JAVA图像对象。它有一个参数image_path。这个参数是一个基于字符串的，指向一个图形文件的路径。</p>
</td>
</tr>
<tr>
<td><center>load_image_from_zip</center></td>
<td><p>::mfp::multimedia::image_lib::load_image_from_zip(3) :</p>
<p>load_image_from_zip(zip_file_name, zip_entry_path, zip_file_type)返回一个被包装过的JAVA图像对象。该图形对象从一个zip压缩文件中读取。它的第一个参数是基于字符串的zip文件的压缩路径。它的第二个参数是图像在该zip文件中的压缩路径。它的第三个参数要么是0，要么是1。如果等于0，表示普通的zip文件，而如果等于1，表示MFP App的安卓assets中的zip文件。</p>
</td>
</tr>
<tr>
<td><center>log</center></td>
<td><p>::mfp::math::log_exp::log(1) :</p>
<p>log(x)返回x的自然对数，注意x可以为复数。</p>
</td>
</tr>
<tr>
<td><center>ls</center></td>
<td><p>::mfp::io::file::ls(1) :</p>
<p>print_file_list(path) (别名ls(path)或者dir(path))函数和Windows平台上的dir命令以及Linux平台上的ls命令类似。它打印出位于字符串path路径的文件或者目录中的所有子文件和子目录的信息。它返回打印的条目的个数。如果不存在一个文件或者目录对应于path路径，它返回-1。注意参数path是可以省略的。它的缺省值是当前目录。例子包括dir() (Windows)和ls("../testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>mod</center></td>
<td><p>::mfp::math::number::mod(2) :</p>
<p>mod(x,y)返回x除以正整数y的余数，如果x或者y不是整数，将被首先转换为整数。</p>
</td>
</tr>
<tr>
<td><center>move_file</center></td>
<td><p>::mfp::io::file::move_file(3) :</p>
<p>move_file(source, destination, replace_exist)函数移动位于字符串source路径的文件或文件夹到位于字符串destination路径的文件或位于destination路径的文件夹内（而不是位于destination路径的文件夹本身）。如果第三个参数，replace_exist，是true，那么如果目标文件已经存在，它将会被源文件（或者源文件夹中的对应文件）替换。注意第三个参数可以省略，它的缺省值为false。例子包括move_file("c:\\temp\\try1", "D:\\", true) (Windows)和copy_file("/mnt/sdcard/testfile.txt", "./testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>now</center></td>
<td><p>::mfp::time_date::now(0) :</p>
<p>now()返回当前时刻和1970年1月1日午夜（UTC）的毫秒数时间差。</p>
</td>
</tr>
<tr>
<td><center>ones</center></td>
<td><p>::mfp::math::matrix::ones(1...) :</p>
<p>ones函数返回一个所有元素都是1的矩阵，本函数的参数用于决定矩阵的尺寸，要么为一批正整数，要么为一个正整数数列。注意函数表达式ones([])返回常数1。</p>
</td>
</tr>
<tr>
<td><center>open_image_display</center></td>
<td><p>::mfp::multimedia::image_lib::open_image_display(1) :</p>
<p>open_image_display(image_path_or_handle)创建一个image display供开发人员调用MFP函数绘图。它有一个参数。这个参数既可以是一个基于字符串的，指向一个图形文件的路径，也可以是null，还可以是一个由load_image，load_image_from_zip，create_image或者clone_image函数返回的JAVA image对象的句柄。</p>
</td>
</tr>
<tr>
<td><center>open_screen_display</center></td>
<td><p>::mfp::graph_lib::display::open_screen_display(6) :</p>
<p>open_screen_display返回一个screen display的句柄。screen display在JAVA平台上是一个窗口，在安卓平台上函数有6个可选参数：caption，background color，confirm quit，size，resizable， orientation。Caption是display的标题，该参数在安卓平台上不起作用；background color是display的背景色，它是一个4个或3个元素的数组，如果是4个元素，就是[Alpha，R，G，B]，如果是3个元素，就是[R，G，B]，在该数组中，每一个元素的值都是从0到255；confirm quit是一个布尔值，用于告诉screen display在退出时是否需要用户确认；size是screen display的大小，它是一个包含两个元素的数组，第一个元素是宽度，第二个元素是高度；resizable是告诉screen display是否可以调整大小，在安卓平台上，size和resizable都没有作用，orientiation仅仅用于安卓平台，用于指定screen display是横向（0），竖向（1）还是任意（-1）。该函数的示例为：</p>
<p>variable display = open_screen_display("Hello world", [255, 238, 17], true, [640, 480], true, 0)</p>
<p>以及</p>
<p>variable display = open_screen_display("Hello")</p>
</td>
</tr>
<tr>
<td><center>or</center></td>
<td><p>::mfp::math::logic::or(1...) :</p>
<p>or(x...)接受不少于1个的任意个数的参数，返回这些参数的逻辑或值。如果某一个参数不是布尔类型，将会被自动转换为布尔类型。</p>
</td>
</tr>
<tr>
<td><center>pause</center></td>
<td><p>::mfp::system::pause(1) :</p>
<p>pause(message)将暂停当前运行的程序，等待用户输入一个回车，然后继续。字符串参数message可以省略。如果不省略，message将作为提示被打印在屏幕上。</p>
</td>
</tr>
<tr>
<td><center>play_sound</center></td>
<td><p>::mfp::multimedia::audio_lib::play_sound(4) :</p>
<p>play_sound(source_path, repeat_or_not, volume, create_new_or_not)演奏一个声音文件，该声音文件可以是wave文件，也可以是midi文件，还可以是mp3文件。该函数返回一个演奏器的句柄，该句柄指向一个JAVA或安卓的多媒体演奏器。由于多媒体演奏器的资源是有限的，本函数会尽可能的回收并重用以前生成的多媒体演奏器。本函数有4个参数。第一个参数是声音文件的路径。第二个参数是一个布尔值，表示该声音是否需要重复演奏，这是一个缺省参数，缺省值是false。第三个参数是一个从0到1的浮点数，表示音量大小。这也是一个缺省参数，缺省值是1。第四个参数是一个布尔值，表示是否无论如何都强制生产一个新的多媒体演奏器。这也是一个缺省参数，缺省值是false。</p>
</td>
</tr>
<tr>
<td><center>play_sound_from_zip</center></td>
<td><p>::mfp::multimedia::audio_lib::play_sound_from_zip(6) :</p>
<p>play_sound_from_zip(source_zip_file_path, zip_entry_path, zip_file_type, repeat_or_not, volume, create_new_or_not)演奏一个从zip文件中抽取出的声音文件，该声音文件可以是wave文件，也可以是midi文件，还可以是mp3文件。该函数返回一个演奏器的句柄，该句柄指向一个JAVA或安卓的多媒体演奏器。由于多媒体演奏器的资源是有限的，本函数会尽可能的回收并重用以前生成的多媒体演奏器。本函数有6个参数。第一个参数是zip文件的路径。第二个参数是被压缩的声音文件的在zip文件中的位置路径。第三个参数是一个布尔值，0表示zip文件是普通的压缩文件，1表示zip文件位于MFP app的安卓asset目录中。第四个参数是一个布尔值，表示该声音是否需要重复演奏，这是一个缺省参数，缺省值是false。第五个参数是一个从0到1的浮点数，表示音量大小。这也是一个缺省参数，缺省值是1。第六个参数是一个布尔值，表示是否无论如何都强制生产一个新的多媒体演奏器。这也是一个缺省参数，缺省值是false。</p>
</td>
</tr>
<tr>
<td><center>plot_2d_curves</center></td>
<td><p>::mfp::graph_lib::plot_math::plot_2d_curves(6...) :</p>
<p>函数plot_2d_curves绘制由最多1024条2-D曲线所构成的图像。其包括以下参数：1.图像名字（图像文件名）；2.图像标题；3.X轴标题；4.Y轴标题；5.图像背景色；6.是否显示网格（注意这个参数是一个字符串，其值为"true"或者"false"）；7.曲线标题；8.曲线数据点颜色；9.曲线数据点形状；10.曲线数据点大小；11.曲线连接线颜色；12.曲线连接线类型；13.曲线连接线粗细；14.内部变量的名字（通常为"t"）；15.内部变量的起始位置；16.内部变量的终止位置；17.内部变量的每一步变化间隔；18.基于内部变量的X的表达式；19.基于内部变量的Y的表达式...。其中，每增加一条新的曲线，需要添加13个参数（也就是参数7到19），最多定义1024条曲线。另外要注意图像背景色，曲线数据点的大小，曲线连接线颜色以及曲线连接线类型还没有被实现，曲线连接线粗细仅支持0（意味着没有连接线连接数据点）和非0（意味着有连接线连接数据点）。本函数的一个例子为：plot_2d_curves("chart 3", "3rd chart", "x", "y", "black", "true", "cv1", "blue", "x", 2, "blue", "solid", 1, "t", -5, 5, 0.1, "t", "t**2/2.5 - 4*t + 6", "cv2", "red", "square", 4, "square", "solid", 1, "t", -10, 10, 0.1, "5*sin(t)", "10*cos(t)") 。</p>
</td>
</tr>
<tr>
<td><center>plot_3d_surfaces</center></td>
<td><p>::mfp::graph_lib::plot_math::plot_3d_surfaces(5...) :</p>
<p>函数plot_3d_surfaces绘制由最多1024条3-D曲面所构成的图像。其包括以下参数：1.图像名字（图像文件名）；2.图像标题；3.X轴标题；4.Y轴标题；5.Z轴标题；6.曲线标题；7.是网格还是填充表面（这是一个布尔值，true是网格，false是填充表面）；8.z值最小的时候的正面的颜色；9.z值最小的时候的反面的颜色；10.最小的z值（注意如果是null，意味着让软件自己找到最小的z值）；11.z值最大的时候的正面的颜色；12.z值最大的时候的反面的颜色；13.最大的z值（注意如果是null，意味着让软件自己找到最大的z值）；14.第一个内部变量的名字（通常为"u"）；15.第一个内部变量的起始值；16.第一个内部变量的终止值；17.第一个内部变量的每一步变化的间隔（0意味着间隔由软件决定）；18.第二个内部变量的名字（通常为"v"）；19.第二个内部变量的起始值；20.第二个内部变量的终止值；21.第二个内部变量的每一步变化的间隔（0意味着间隔由软件决定）；22.基于前述两个内部变量的X的表达式；23.基于前述两个内部变量的Y的表达式；24.基于前述两个内部变量的Z的表达式；...。其中，每增加一条新的曲面，需要添加19个参数（也就是参数6到24），最多定义1024条曲面。该函数的一个例子为：plot_3D_surfaces("chartI", "first chart", "x", "y", "z", "Curve1", false, "red", "cyan", -0.5, "green", "yellow", null, "u", 0, pi, pi/8, "v", -pi/2, pi/2, 0, "sin(u)*cos(v)", "sin(u)*sin(v)", "cos(u)")　。</p>
</td>
</tr>
<tr>
<td><center>plot_multi_rangle</center></td>
<td><p>::mfp::graph_lib::plot_math::plot_multi_rangle(2...) :</p>
<p>plot_multi_rangle(包含>=2个参数)用于绘制2维或极坐标图像，每个图像最多包括1024条曲线。参数1为图像名字，参数2为图像设置，该参数是一个字符串，比如"chart_type:multiXY;chart_title:1 chart;x_title:x;x_min:-6.2796950076838645;x_max:6.918480857169536;x_labels:10;y_title:y;y_min:-4.487378580559947;y_max:4.1268715788884345;y_labels:10;background_color:black;show_grid:true"。注意chart_type的值是multiXY（用于绘制二维图像）或者multiRangle（用于绘制极坐标图像），x_labels和y_lables分别代表x和y轴上有多少刻度标记（对于极坐标图像是R轴有多少刻度标记，幅角的刻度标记不可设）。从参数3开始，每3个参数定义一条曲线，在这3个参数中，第一个参数为曲线设置，第二个参数是包含所有x数值（或者R数值）的向量，第三个参数是包括所有y值（或者幅角值）的向量。曲线设置参数为一个字符串，比如"curve_label:cv2;point_color:blue;point_style:point;point_size:1;line_color:blue;line_style:solid;line_size:1"。另外注意x和y的每一个数值都必须为实数，x和y的数值个数必须一致。本函数不返回数值。本函数的一个例子是plot_multi_rangle("chart2", "chart_type:multiXY;chart_title:1 chart;x_title:x;x_min:-6;x_max:6;x_labels:6;y_title:y;y_min:-4;y_max:4;y_labels:5;background_color:black;show_grid:true", "curve_label:cv2;point_color:blue;point_style:circle;point_size:3;line_color:blue;line_style:solid;line_size:1", [-5, -3, -1, 0, 1, 2, 3, 4, 5], [-3.778, -2.9793, -2.0323, -1.1132, 0.2323, 1.2348, 3.9865, 2.3450, 0.4356]) 。</p>
</td>
</tr>
<tr>
<td><center>plot_multi_xy</center></td>
<td><p>::mfp::graph_lib::plot_math::plot_multi_xy(2...) :</p>
<p>plot_multi_xy(包含>=2个参数)用于绘制2维或极坐标图像，每个图像最多包括1024条曲线。参数1为图像名字，参数2为图像设置，该参数是一个字符串，比如"chart_type:multiXY;chart_title:1 chart;x_title:x;x_min:-6.2796950076838645;x_max:6.918480857169536;x_labels:10;y_title:y;y_min:-4.487378580559947;y_max:4.1268715788884345;y_labels:10;background_color:black;show_grid:true"。注意chart_type的值是multiXY（用于绘制二维图像）或者multiRangle（用于绘制极坐标图像），x_labels和y_lables分别代表x和y轴上有多少刻度标记（对于极坐标图像是R轴有多少刻度标记，幅角的刻度标记不可设）。从参数3开始，每3个参数定义一条曲线，在这3个参数中，第一个参数为曲线设置，第二个参数是包含所有x数值（或者R数值）的向量，第三个参数是包括所有y值（或者幅角值）的向量。曲线设置参数为一个字符串，比如"curve_label:cv2;point_color:blue;point_style:point;point_size:1;line_color:blue;line_style:solid;line_size:1"。另外注意x和y的每一个数值都必须为实数，x和y的数值个数必须一致。本函数不返回数值。本函数的一个例子是plot_multi_xy("chart2", "chart_type:multiXY;chart_title:1 chart;x_title:x;x_min:-6;x_max:6;x_labels:6;y_title:y;y_min:-4;y_max:4;y_labels:5;background_color:black;show_grid:true", "curve_label:cv2;point_color:blue;point_style:circle;point_size:3;line_color:blue;line_style:solid;line_size:1", [-5, -3, -1, 0, 1, 2, 3, 4, 5], [-3.778, -2.9793, -2.0323, -1.1132, 0.2323, 1.2348, 3.9865, 2.3450, 0.4356]) 。</p>
</td>
</tr>
<tr>
<td><center>plot_multi_xyz</center></td>
<td><p>::mfp::graph_lib::plot_math::plot_multi_xyz(2...) :</p>
<p>plot_multi_xyz(包含>=2个参数)用于绘制3维图像，每个图像最多包括1024条曲面。参数1为图像名字，参数2为图像设置，图像设置参数是一个字符串，比如"chart_type:multiXYZ;chart_title:This is a graph;x_title:x axis;x_min:-24.43739154366772;x_max:24.712391543667717;x_labels:10;y_title:Y axis;y_min:-251.3514430737091;y_max:268.95144307370913;y_labels:10;z_title:Z axis;z_min:-1.6873277335234405;z_max:1.7896774628184482;z_labels:10"。需要注意的是chart_type的值必须是multiXYZ，x_labels，y_labels和z_lables分别代表x，y和z轴上有多少刻度标记。从参数3开始，每4个参数定义一条曲线，在这4个参数中，第一个参数为曲线设置，第二个参数是包含所有x数值的矩阵，第三个参数是包括所有y值的矩阵，第四个参数是包括所有z值的矩阵。曲线设置参数为一个字符串，比如"curve_label:cv2;is_grid:true;min_color:blue;min_color_1:cyan;min_color_value:-2.0;max_color:white;max_color_1:yellow;max_color_value:2.0"。另外注意x，y和z的每一个数值都必须为实数，x，y和z的矩阵的尺寸必须一致。本函数不返回数值。本函数的一个例子为：plot_multi_xyz("chartII", "chart_type:multiXYZ;chart_title:This is a graph;x_title:x;x_min:-5;x_max:5;x_labels:6;y_title:Y;y_min:-6;y_max:6;y_labels:3;z_title:Z;z_min:-3;z_max:1;z_labels:4", "curve_label:cv1;min_color:blue;min_color_1:green;max_color:yellow;max_color_1:red", [[-4, -2, 0, 2, 4],[-4, -2, 0, 2, 4],[-4, -2, 0, 2, 4]], [[-5, -5, -5, -5, -5], [0, 0, 0, 0, 0], [-5, -5, -5, -5, -5]], [[-2.71, -2.65, -2.08, -1.82, -1.77], [-2.29, -2.36, -1.88, -1.45, -1.01], [-1.74, -1.49, -0.83, -0.17, 0.44]]) 。</p>
</td>
</tr>
<tr>
<td><center>plot_polar_curves</center></td>
<td><p>::mfp::graph_lib::plot_math::plot_polar_curves(6...) :</p>
<p>函数plot_polar_curves绘制由最多1024条极坐标曲线所构成的图像。其包括以下参数：1.图像名字（图像文件名）；2.图像标题；3.幅度轴标题；4.幅角标题（需要注意幅角标题在图中实际上不会被显示）；5.图像背景色；6.是否显示网格（注意这个参数是一个字符串，其值为"true"或者"false"）；7.曲线标题；8.曲线数据点颜色；9.曲线数据点形状；10.曲线数据点大小；11.曲线连接线颜色；12.曲线连接线类型；13.曲线连接线粗细；14.内部变量的名字（通常为"t"）；15.内部变量的起始位置；16.内部变量的终止位置；17.内部变量的每一步变化间隔；18.基于内部变量的幅度的表达式；19.基于内部变量的幅角的表达式...。其中，每增加一条新的曲线，需要添加13个参数（也就是参数7到19），最多定义1024条曲线。另外要注意图像背景色，曲线数据点的大小，曲线连接线颜色以及曲线连接线类型还没有被实现，曲线连接线粗细仅支持0（意味着没有连接线连接数据点）和非0（意味着有连接线连接数据点）。本函数的一个例子为：plot_polar_curves("chart 3", "3rd chart", "R", "angle", "black", "false", "cv1", "blue", "x", 2, "blue", "solid", 1, "t", -5, 5, 0.1, "t", "t**2/2.5 - 4*t + 6", "cv2", "red", "square", 4, "square", "solid", 1, "t", -10, 10, 0.1, "5*sin(t)", "10*cos(t)") 。</p>
</td>
</tr>
<tr>
<td><center>pow</center></td>
<td><p>::mfp::math::log_exp::pow(2) :</p>
<p>pow(x,y)返回x的y次方，注意x和y可以为实数，可以为虚数。如果结果有多个值，返回第一个值。</p>
<p>::mfp::math::log_exp::pow(3) :</p>
<p>pow(x,y,z)返回包含x的y次方的前z个值组成的一个向量，如果x的y次方只有少于z个值，返回所有值。注意y必须为实数，x可以为实数，可以为虚数，z必须为正整数。</p>
</td>
</tr>
<tr>
<td><center>print</center></td>
<td><p>::mfp::io::console::print(1) :</p>
<p>print(x)向输出端打印任意数据类型x的值。</p>
</td>
</tr>
<tr>
<td><center>print_file_list</center></td>
<td><p>::mfp::io::file::print_file_list(1) :</p>
<p>print_file_list(path) (别名ls(path)或者dir(path))函数和Windows平台上的dir命令以及Linux平台上的ls命令类似。它打印出位于字符串path路径的文件或者目录中的所有子文件和子目录的信息。它返回打印的条目的个数。如果不存在一个文件或者目录对应于path路径，它返回-1。注意参数path是可以省略的。它的缺省值是当前目录。例子包括dir() (Windows)和ls("../testfile_copy.txt") (Android)。</p>
</td>
</tr>
<tr>
<td><center>print_line</center></td>
<td><p>::mfp::io::console::print_line(1) :</p>
<p>print_line(x)向输出端打印任意数据类型x的值然后再起一行。注意x是一个可选参数，它的缺省值是空字符串""。</p>
</td>
</tr>
<tr>
<td><center>printf</center></td>
<td><p>::mfp::io::console::printf(1...) :</p>
<p>printf(format_string, ...)，sprintf(format_string, ...)和fprintf(fd, format_string, ...)和C/C++中的对应函数工作方式相似。这些函数通过format_string和其后的数值参数构造出一个新的字符串，printf函数将字符串打印到标准输出，sprintf函数将字符串作为返回值返回，fprintf函数则将字符串输出到文件号为fd的文本文件。字符串format_string支持输入整数（%d、%i、%x等），浮点数（%e、%f等），字符和字符串（%c和%s）等等。用户可以在C语言的帮助文档中找到format_string的构造方法。例如，printf("Hello world!%f", 3.14)将会打印输出"Hello world!3.140000"，而sprintf("%c%d", "A", 9)则返回"A9"（注意MFP不支持单一字符数据类型，所以单一的字符将会存储为一个只包括一个字符的字符串）。</p>
</td>
</tr>
<tr>
<td><center>product_over</center></td>
<td><p>::mfp::math::stat_stoch::product_over(3) :</p>
<p>函数product_over(x, y, z)计算基于字符串的表达式x中的变量取值从整数y逐步变化到整数z的值的乘积。y和z必须是字符串的形式，其中，y必须写成一个赋值表达式，比如"a=10"，这里，a是变量名。一个函数的例子为product_over("x+1", "x=1", "10")。</p>
</td>
</tr>
<tr>
<td><center>pull_event</center></td>
<td><p>::mfp::graph_lib::event::pull_event(1) :</p>
<p>pull_event(display)从screen display的输入事件（比如，鼠标事件或者触摸屏的手势事件）序列中按顺序取走一个事件。如果没有输入事件，或者不是screen display而是image display，它返回Null，否则返回输入事件。</p>
</td>
</tr>
<tr>
<td><center>pwd</center></td>
<td><p>::mfp::io::file::pwd(0) :</p>
<p>get_working_dir()（别名pwd()）返回基于字符串的当前路径。</p>
</td>
</tr>
<tr>
<td><center>rand</center></td>
<td><p>::mfp::math::stat_stoch::rand(0) :</p>
<p>rand()函数返回一个大于等于0小于1的随机浮点数。</p>
</td>
</tr>
<tr>
<td><center>rank</center></td>
<td><p>::mfp::math::matrix::rank(1) :</p>
<p>rank(matrix)返回矩阵的秩。比如，rank([[1,2],[2,4]])将返回1。</p>
</td>
</tr>
<tr>
<td><center>read_file</center></td>
<td><p>::mfp::io::file::read_file(2) :</p>
<p>函数read_file读入一个文件并返回该文件的内容。它有两个参数。第一个参数是文件的路径。第二个参数是读入模式。读入模式是一个字符串。如果读入模式是"b"或者"B"意味着以以二进制方式读入，该函数会返回一个二进制数组。如果是其它字符串，则意味着以文本方式读入，该函数会返回一个字符串。第二个参数可以省略。在第二个参数缺省时本函数以文本方式读入文件并返回字符串 。</p>
</td>
</tr>
<tr>
<td><center>real</center></td>
<td><p>::mfp::math::complex::real(1) :</p>
<p>real(x)返回复数x的实部。</p>
</td>
</tr>
<tr>
<td><center>receive_rtc_mmedia_message</center></td>
<td><p>::mfp::multimedia::webrtc_lib::receive_rtc_mmedia_message(1) :</p>
<p>此函数取回一个web RTC消息。注意此处的web RTC是指的用于支持声音和视频通信的web RTC函数库，而不是用于支持数据通信的WEBRTC协议栈。本函数只有一个参数，就是等待的时间。如果该参数是一个正数，则代表等待的毫秒数。如果该参数是0，函数立即返回。如果是一个负数，函数会阻塞等待直到有消息到来。如果在等待超时后仍然没有消息到来，则返回null。如果函数取回了一个合法的消息，则该函数的返回值是一个四个元素的数组。第一个元素是消息的目标peer connection对象的id。第二个元素是当前RTC会话的id。第三个元素是消息的类型。最后一个元素是消息的内容。如果消息是RTC信令，消息的类型则是"signal"，而消息的内容则是一个Json字符串。该Json字符串的"type"域值是信令的类型，也就是"offer"，"answer"或者"candidate"；如果信令的类型是"offer"或者"answer"，则该Json字符串的"sdp"域值是SDP的内容。如果消息是peer connection的事件，消息的类型则是"pc"，而消息的内容则是一个Json字符串。该Json字符串的"type"域值是事件的类型，比如"ice_connection_change"；而"content"域值则是基于字符的事件内容。</p>
</td>
</tr>
<tr>
<td><center>receive_sandbox_message</center></td>
<td><p>::mfp::paracomp::connect::receive_sandbox_message(1...) :</p>
<p>receive_sandbox_message函数返回沙盒或者MFP主进程发送的信息。发送者可能位于一个和本地有直接连接（这里指的是通过MFP的connect函数构成的连接）的远端MFP实例中（可能是一个call沙盒或者该MFP实例的主进程），也可能就是本地MFP实例的一个call沙盒或者该MFP实例的主进程。它有两种工作模式。第一种工作模式只有一个参数，也就是等待的时间。如果是0，则意味着没有等待，立即返回。如果队列中有消息，则返回队列中的第一个消息，否则，返回NULL。如果等待时间小于0，则意味着阻塞模式。也就是说如果队列中没有消息，函数将会阻塞。如果等待时间是正数，则代表等待的毫秒数。如果等待时间过去之后队列中仍然没有消息，则返回NULL。如果本函数是在沙盒中被调用，则必须采用第一种工作模式。第二种工作模式有两个参数。第一个参数为一个代表本地信息（也就是监听地址）的对象。它告诉本函数选择哪一个本地地址收取消息。该信息对象可由调用generate_interface函数返回得到。第二个参数则是等待时间，其具体意义参见第一种工作模式。如果本函数是在MFP主进程中被调用，则必须采用第二种工作模式。本函数如果返回一个合法的消息，该返回值则是一个基于数组的字典。其中，“InterfaceInfo”的字段是发送端的本地信息，包括协议和地址。如果发送端和接收端位于同一个MFP实例中，并且接收端是该MFP实例的一个call沙盒而发送端是该MFP实例的主进程，这个字段则为NULL。“ConnectId”的字段是发送端的连接ID，如果发送端是MFP实例的主进程，该字段为一个空字符串。“CallId”的字段是发送端的call沙盒ID，如果发送端是MFP实例的主进程，该字段为0。“TransConnectSrcLocal”字段是传输连接发送端自己看到的本地地址。这里，传输连接未必是发送或者接收端call沙盒的发起连接。但传输连接的两端必然分别位于发送端和接收端所在的MFP实例中。发送端，无论是call沙盒还是MFP主进程，将要发送的消息交给MFP实例，然后发送端MFP实例将该消息通过传输连接发送到接收端的MFP实例，再由接收端MFP实例将消息配送到目标沙盒或者MFP主进程。注意由于传输连接是双向的，发送端不一定是传输连接的客户端，相应地，接收端也不一定是传输连接的服务端。类似地，字段“TransConnectSrcRemote”是传输连接发送端看到的接收端地址；字段“TransConnectDestLocal”是传输连接接收端自己看到的本地地址；字段“TransConnectDestRemote”是传输连接接收端看到的发送端地址。通常情况下，字段“TransConnectSrcLocal”和“TransConnectDestRemote”的值应该是一致的，字段“TransConnectSrcRemote”和“TransConnectDestLocal”的值应该是一致的。但是，如果是TCPIP协议并且发送端和接收端之间存在NAT层，这些字段的值不见得会一致。如果接收端位于传输连接的服务端，“TransConnectDestRemote”字段的值会非常有用，因为它可以告诉MFP传输连接在服务端的id，只有知道id该连接才可以被重用，并且还可以通过该连接发送回复的消息。如果发送端和接收端位于同一个MFP实例中，则不需要通过传输连接发送消息，这种情况下上述4个字段的内容都是空字符串。最后，消息的“Message”的字段是消息的内容。本函数的两个例子为receive_sandbox_message(-1)和receive_sandbox_message(local_info, -1)。</p>
</td>
</tr>
<tr>
<td><center>recip</center></td>
<td><p>::mfp::math::matrix::recip(1) :</p>
<p>recip(x)计算x的倒数，注意当前仅支持数值或二维矩阵。</p>
</td>
</tr>
<tr>
<td><center>remove_elem_from_ablist</center></td>
<td><p>::mfp::data_struct::array_based::remove_elem_from_ablist(2) :</p>
<p>remove_elem_from_ablist(array_based_list, idx)将基于数组的序列array_based_list的idx号元素删除并返回更新后的基于数组的序列。作为参数的array_based_list和返回值共享元素。注意idx必须是一个合法的索引。</p>
</td>
</tr>
<tr>
<td><center>remove_peer_stream</center></td>
<td><p>::mfp::multimedia::webrtc_lib::remove_peer_stream(1) :</p>
<p>此函数移除peer connection对象的视频流。这个函数仅有一个参数，也就是peer connection对象的Id。这个函数不返回任何值。</p>
</td>
</tr>
<tr>
<td><center>round</center></td>
<td><p>::mfp::math::number::round(1) :</p>
<p>round(x)，x是浮点数，返回x的四舍五入值。</p>
<p>::mfp::math::number::round(2) :</p>
<p>round(x,y)，x是浮点数，y为非负整数，返回小数点后有y位数字的x的四舍五入值。</p>
</td>
</tr>
<tr>
<td><center>save_image</center></td>
<td><p>::mfp::multimedia::image_lib::save_image(3) :</p>
<p>save_image(image, file_format, path)保存一个被包装过的JAVA图像对象至一个图形文件。本函数的第一个参数是被包装过的JAVA图像对象，第二个参数是基于字符串的图像文件的格式，当前仅支持"png"，"jpg"以及"bmp"格式。第三个参数是图像文件的路径。如果成功保存，本函数返回True，否则返回False。本函数的一个例子为：save_image(img, "png", "C:\\Temp\\1.png")。</p>
</td>
</tr>
<tr>
<td><center>scanf</center></td>
<td><p>::mfp::io::console::scanf(1) :</p>
<p>scanf(format_string)，sscanf(input_from, format_string)和fscanf(fd, format_string)和C/C++中的对应函数工作方式相似。scanf读取用户的一行输入，sscanf读取字符串input_from，fscanf从文件（文件号fd）中读取文件内容。字符串format_string支持输入整数（%d、%i、%x等），浮点数（%e、%f等），字符和字符串（%c和%s）等等。用户可以在C语言的帮助文档中找到format_string的构造方法。但是，和C语言有所不同，MFP中的这些函数不需要输入用于存储读取数值的参数。所有的读取的数值将会保存在一个数组中作为返回值返回。比如，sscanf("3Hello world!", "%d%c%c%s")将会返回[3, "H", "e", "llo"]（注意MFP不支持单一字符数据类型，所以单一的字符将会存储为一个只包括一个字符的字符串）。</p>
</td>
</tr>
<tr>
<td><center>send_sandbox_message</center></td>
<td><p>::mfp::paracomp::connect::send_sandbox_message(1...) :</p>
<p>send_sandbox_message函数将消息发送到沙盒或MFP主进程。它具有四种工作模式。第一种工作模式是从沙盒向其本地MFP主进程发送消息。在这种情况下，该功能只有一个参数，即消息内容。请注意，消息内容不必是字符串。例如，send_sandbox_message([1,2,3])从沙盒向本地MFP主进程发送[1,2,3]。第二种工作模式是将消息从MFP主进程或沙盒发送到本地沙盒。在这种情况下，该功能需要四个参数。第一个参数是本地信息对象。可以从generate_interface函数获得此本地信息对象。启动接收方沙盒的call请求被本地信息对象所代表的接口地址接受。第二个参数是接收方沙盒的连接ID。注意这个连接是启动接收方沙盒call对象的连接。第三个参数是接收方沙盒的call沙盒Id。最后一个参数是消息内容。此模式的一个示例是send_sandbox_message(local_info,"127.0.0.1",1,238.975+3.01i)。第三种工作模式是将消息从本地沙盒或MFP主进程发送到远端MFP主进程。请注意，本地MFP实例必须已经通过调用connect函数连接到远端MFP实例。此模式需要两个参数。第一个是从connect函数返回的连接对象（即返回值的“CONNECT”字段）。第二个参数是消息内容。一个示例是send_sandbox_message(conn1,"Hello!")。最后一种工作模式是将消息从本地沙盒或MFP主进程发送到远端沙盒。请注意，本地MFP实例必须通过调用connect函数连接到远端MFP实例。此模式需要五个参数。第一个参数是从连接函数返回的连接对象（即返回值的“CONNECT”字段）。第二个参数是从generate_interface函数获得的远程接口对象。此远程接口位于连接的另一端。远程接口接受了启动接收方沙盒的call请求。第三个参数是接收方沙盒的连接ID。注意这个连接是启动接收方沙盒call对象的连接。第四个参数是接收方沙盒的call沙盒ID。最后一个参数是消息内容。此模式的一个示例是send_sandbox_message(conn1,remote_info,"192.168.1.139",4,[[1,2],[3,4]])。</p>
</td>
</tr>
<tr>
<td><center>set_array_elem</center></td>
<td><p>::mfp::array::set_array_elem(3) :</p>
<p>set_array_elem(x,y,z)将x[y]赋值为z，并且返回新的x。注意x不是必须为矩阵，y必须为正整数向量。y的值可以超出x的尺寸和维度。比如，如果x=3，y=[1,2]，z=2+3i，那么set_array_elem(x,y,z)等于[3, [0, 0, 2+3i]]。还要注意，调用了set_array_elem函数之后，x的值可能会自动变为新值，也可能不会。所以，必须将set_array_elem的返回值赋予x，以保证x的值得到更新。</p>
</td>
</tr>
<tr>
<td><center>set_audio_track_enable</center></td>
<td><p>::mfp::multimedia::webrtc_lib::set_audio_track_enable(2) :</p>
<p>此函数激活或者关闭音轨。这个函数有两个参数。第一个参数是一个显示窗口的句柄。该显示窗口的句柄可以从open_screen_display函数调用中返回。第二个是一个布尔值，True表示激活音轨而false则表示关闭音轨。这个函数的返回值是音轨之前的状态。True表示函数调用之前是激活状态而false则表示函数调用之前是关闭状态。</p>
</td>
</tr>
<tr>
<td><center>set_display_bgrnd_color</center></td>
<td><p>::mfp::graph_lib::display::set_display_bgrnd_color(2) :</p>
<p>set_display_bgrnd_color(display, color)为一个display设置背景色。该display既可以是screen display，也可以是image display。背景色是一个4个或3个元素的数组，如果是4个元素，就是[Alpha，R，G，B]，如果是3个元素，就是[R，G，B]，在该数组中，每一个元素的值都是从0到255。</p>
</td>
</tr>
<tr>
<td><center>set_display_bgrnd_image</center></td>
<td><p>::mfp::graph_lib::display::set_display_bgrnd_image(3) :</p>
<p>set_display_bgrnd_image(display, image, mode)为一个display设置背景图像。该display既可以是screen display，也可以是image display。背景图像是一个image句柄。mode是背景图像的布置方式，0表示原始背景图像被置于左上角，1表示背景图像被缩放值screen大小以便覆盖整个screen，2表示背景图像如贴瓷砖一样重复整齐排列，但每一片“瓷砖”大小保持原状， 3背景图像位于屏幕正中央。在这种情况下背景图像的大小也不会改变。</p>
</td>
</tr>
<tr>
<td><center>set_display_caption</center></td>
<td><p>::mfp::graph_lib::display::set_display_caption(2) :</p>
<p>set_display_caption(display, caption)在JAVA平台上设置一个screen display的标题。set_display_resizable对image display不起作用，在安卓平台上也不起作用。</p>
</td>
</tr>
<tr>
<td><center>set_display_confirm_close</center></td>
<td><p>::mfp::graph_lib::display::set_display_confirm_close(2) :</p>
<p>set_display_confirm_close(display, confirm_close_or_not)设置关闭一个screen display是否需要确认。set_display_confirm_close对image display不起作用。</p>
</td>
</tr>
<tr>
<td><center>set_display_orientation</center></td>
<td><p>::mfp::graph_lib::display::set_display_orientation(2) :</p>
<p>set_display_orientation(display, orientation)设置安卓平台上一个screen display是横屏（orientation等于0）还是竖屏（orientation等于1）还是横竖均可（orientation等于-1）。set_display_orientation对image display不起作用，在JAVA平台上也不起作用。</p>
</td>
</tr>
<tr>
<td><center>set_display_resizable</center></td>
<td><p>::mfp::graph_lib::display::set_display_resizable(2) :</p>
<p>set_display_resizable(display, resizable_or_not)设置一个screen display是否可以改变大小。set_display_resizable对image display不起作用。</p>
</td>
</tr>
<tr>
<td><center>set_display_size</center></td>
<td><p>::mfp::graph_lib::display::set_display_size(3) :</p>
<p>set_display_size(display, width, height)设置一个display（既可以是screen display，也可以是image display）的长度和高度分别为width和height。</p>
</td>
</tr>
<tr>
<td><center>set_display_snapshot_as_bgrnd</center></td>
<td><p>::mfp::graph_lib::display::set_display_snapshot_as_bgrnd(3) :</p>
<p>set_display_snapshot_as_bgrnd(display, update_screen_or_not, clear_callbacks_or_not)将一个display（既可以是screen display，也可以是image display）的截屏设置为它的背景图案。它的第二个参数，update_screen_or_not，告诉MFP在截屏之前该display是否需要刷新；它的第三个参数，clear_callbacks_or_not，告诉MFP是否需要将屏幕绘图事件序列清空。比如，set_display_snapshot_as_bgrnd(d, true, true)首先刷新屏幕d，然后将屏幕绘图事件序列清空，最后截屏并将所得图像作为屏幕背景图像。</p>
</td>
</tr>
<tr>
<td><center>set_elem_in_ablist</center></td>
<td><p>::mfp::data_struct::array_based::set_elem_in_ablist(3) :</p>
<p>set_elem_in_ablist(array_based_list, idx, ref_of_elem)将基于数组的序列array_based_list在idx处的值设置为ref_of_elem的引用。如果idx不合法，一个异常将会被抛出。</p>
</td>
</tr>
<tr>
<td><center>set_file_last_modified_time</center></td>
<td><p>::mfp::io::file::set_file_last_modified_time(2) :</p>
<p>set_file_last_modified_time(path, time)设置基于字符串路径的path的文件或目录的上一次更改时间为time。该时间等于从1970年1月1日午夜开始到上一次更改时刻所经历的毫秒数。如果path不存在或者没有访问权限，返回false，否则返回true。例子包括("C:\\Temp\\Hello\\", 99999999) (Windows)和set_file_last_modified_time("./hello.txt", 1111111111) (Android)。</p>
</td>
</tr>
<tr>
<td><center>set_json_field</center></td>
<td><p>::mfp::exdata::json::set_json_field(3) :</p>
<p>此函数将一个值设置到代表JSON数据的字符串中。此函数有三个参数。第一个参数为一个代表JSON数据的字符串，第二个参数为JSON域的名字，第三个参数为JSON域的值。注意这三个参数都是区分大小写的。如果这个JSON域已经存在，则将新值写入，否则，将创建一个新的JSON域。这个函数的返回值是设置后的新的JSON域的字符串，或者如果数据类型不支持或JSON域的名字错误则抛出异常。本函数的一个例子是set_json_field("{\"ABC\": null, \"JJJ\": {\"DEF\":[1, 8, [\"Welcome\", 9.99]],\"ZZ\":\"hello boy\"}}", "JJJ", "New value")。</p>
</td>
</tr>
<tr>
<td><center>set_local_host_address</center></td>
<td><p>::mfp::paracomp::host::set_local_host_address(4) :</p>
<p>set_local_host_address函数用于设置所选通信协议的本地地址。它有四个参数。第一个参数是通信协议的的名字。当前只支持WEBRTC协议所以它只能是字符串"WEBRTC"。第二个参数是通信接口的名称，当前支持"main"作爲参数值。第三个参数是通信地址。由于仅支持WEBRTC协议，通信地址必须是一个合法的电子邮件地址。推荐使用微软的outlook邮件或者腾讯公司的QQ邮件。第四个参数是一个字符串数组。数组中的第一个元素为"0"，代表该email地址支持smtp和imap协议。数组中的第二个元素为电子邮件的密码。注意这是smtp和imap协议收发邮件所使用的密码，该密码未见得和登录网页信箱所需要的密码一样。如果开发人员使用微软的outlook邮件或者hotmail邮箱，或者谷歌的gmail，以及腾讯的QQ邮件，以上信息就足够了。但是，如果是其他的邮件地址，开发人员则需要提供smtp服务器和imap服务器的信息。这包括smtp服务器的地址，端口，是否支持SSL协议，和imap服务器的地址，端口，以及是否支持SSL协议。其中，是否支持SSL协议也是一个字符串，"0"表示不支持，"1"表示支持，"-1"表示不清楚。这些信息将分别填入第四个参数的第三号到第八号元素中。本函数的一个例子是set_local_host_address("WEBRTC", "main", "abcxyz@yahoo.com", ["0", "xxxxyyyyzzzzwwww", "smtp.mail.yahoo.com", "465", "1", "imap.mail.yahoo.com", "993", "1"])。另外一个例子是set_local_host_address("WEBRTC", "main", "mnopqrst@outlook.com", ["0", "abcd1234"])。</p>
</td>
</tr>
<tr>
<td><center>set_porterduff_mode</center></td>
<td><p>::mfp::graph_lib::draw::set_porterduff_mode(2) :</p>
<p>set_porterduff_mode(painting_extra, porterduff_mode)为一个painting extra数据结构设置porterduff模式。painting extra数据结构在painting事件中被调用。Porterduff模式告诉MFP如何绘制目标区域。它是一个大写的字符串，具有以下可能值："CLEAR"，"SRC"，"DST"，"SRC_OVER"，"DST_OVER"，"SRC_IN"，"DST_IN"，"SRC_OUT"，"DST_OUT"，"SRC_ATOP"，"DST_ATOP"，"XOR"或者""，其中，空字符串""是缺省值。开发者可以参考JAVA文档以获取porterduff模式的详细信息。由于porterduff模式的使用非常复杂，在不十分清楚porterduff模式内部机制的情况下，不建议用户调用此函数。换句话说，使用porterduff模式的缺省值在一般情况下足以满足用户的需求。</p>
</td>
</tr>
<tr>
<td><center>set_rtc_media_remote_description</center></td>
<td><p>::mfp::multimedia::webrtc_lib::set_rtc_media_remote_description(3) :</p>
<p>本函数在接收到一个answer信令之后设置web RTC的远程描述。注意此处的web RTC是指的用于支持声音和视频通信的web RTC函数库，而不是用于支持数据通信的WEBRTC协议栈。本函数有3个参数。第一个是peer connection对象的id。第二个是SDP的类型。该参数应该就是一个"answer"字符串。第三个参数是SDP的内容，也就是answer信令的内容。本函数不返回任何值。本函数的一个例子是set_rtc_media_remote_description(remoteAddr, sdpType, sdpContent)。</p>
</td>
</tr>
<tr>
<td><center>set_sound_repeat</center></td>
<td><p>::mfp::multimedia::audio_lib::set_sound_repeat(2) :</p>
<p>set_sound_repeat(sound_handle, repeat_or_not)设置一个sound_handle所代表的声音是否重复演奏。</p>
</td>
</tr>
<tr>
<td><center>set_sound_volume</center></td>
<td><p>::mfp::multimedia::audio_lib::set_sound_volume(2) :</p>
<p>set_sound_volume(sound_handle, volume)设置一个sound_handle所代表的声音的音量，注意音量参数volume的值变化范围是从0到1。</p>
</td>
</tr>
<tr>
<td><center>set_value_in_abdict</center></td>
<td><p>::mfp::data_struct::array_based::set_value_in_abdict(3) :</p>
<p>set_value_in_abdict(array_based_dictionary, key, value)将基于数组的字典array_based_dictionary的key所对于的值设置为value的引用并返回修改过的字典。如果key不存在，它将会被创造出来。注意key只能是字符串但是value可以是任意数据类型。</p>
</td>
</tr>
<tr>
<td><center>set_video_track_enable</center></td>
<td><p>::mfp::multimedia::webrtc_lib::set_video_track_enable(2) :</p>
<p>此函数激活或者关闭视频功能。这个函数有两个参数。第一个参数是一个显示窗口的句柄。该显示窗口的句柄可以从open_screen_display函数调用中返回。第二个是一个布尔值，True表示激活视频功能而false则表示关闭视频功能。这个函数的返回值是视频功能之前的状态。True表示函数调用之前是激活状态而false则表示函数调用之前是关闭状态。</p>
</td>
</tr>
<tr>
<td><center>shutdown_display</center></td>
<td><p>::mfp::graph_lib::display::shutdown_display(2) :</p>
<p>shutdown_display函数用于关闭一个display。该display既可以是一个窗口，也就是screen display，也可以是一个图像，也就是image display。它有两个参数。第一个参数是该display，第二个参数是一个可选参数，它是一个布尔值，true表示关闭screen display时不需要用户确认，而不管在该display创建时，有无设置需要确认退出。它的缺省值是false。注意它对image display不起作用。该函数的例子包括：</p>
<p>shutdown_display(d)</p>
<p>以及</p>
<p>shutdown_display(d, true)</p>
</td>
</tr>
<tr>
<td><center>sin</center></td>
<td><p>::mfp::math::trigon::sin(1) :</p>
<p>sin(x)返回x的正弦值，注意x可以为复数。</p>
</td>
</tr>
<tr>
<td><center>size</center></td>
<td><p>::mfp::array::size(1) :</p>
<p>size(x)返回矩阵x的尺寸向量。注意如果x不是一个矩阵，则总是返回[]。</p>
<p>::mfp::array::size(2) :</p>
<p>size(x,y)返回矩阵x前y维的尺寸向量，如果x少于y维，返回完整的尺寸向量，注意y必须为正整数。此外如果x不是一个矩阵，则总是返回[]。</p>
</td>
</tr>
<tr>
<td><center>sleep</center></td>
<td><p>::mfp::system::sleep(1) :</p>
<p>sleep(x)休眠x毫秒（x必须为正实数），此函数不返回任何值。</p>
</td>
</tr>
<tr>
<td><center>split</center></td>
<td><p>::mfp::string::split(2) :</p>
<p>split(string_input, string_regex)j将字符串string_input按照正则表达式string_regex分割为若干个子字符串并返回包含所有子字符串的数组。用户可以阅读JAVA语言的Pattern类和String.split函数的帮助文档获得更多关于正则表达式使用方法的信息。例子包括split("boo:and:foo", ":")返回["boo", "and", "foo"]以及split("boo:and:foo", "o")返回["b", "", ":and:f"]。</p>
</td>
</tr>
<tr>
<td><center>sprintf</center></td>
<td><p>::mfp::string::sprintf(1...) :</p>
<p>printf(format_string, ...)，sprintf(format_string, ...)和fprintf(fd, format_string, ...)和C/C++中的对应函数工作方式相似。这些函数通过format_string和其后的数值参数构造出一个新的字符串，printf函数将字符串打印到标准输出，sprintf函数将字符串作为返回值返回，fprintf函数则将字符串输出到文件号为fd的文本文件。字符串format_string支持输入整数（%d、%i、%x等），浮点数（%e、%f等），字符和字符串（%c和%s）等等。用户可以在C语言的帮助文档中找到format_string的构造方法。例如，printf("Hello world!%f", 3.14)将会打印输出"Hello world!3.140000"，而sprintf("%c%d", "A", 9)则返回"A9"（注意MFP不支持单一字符数据类型，所以单一的字符将会存储为一个只包括一个字符的字符串）。</p>
</td>
</tr>
<tr>
<td><center>sscanf</center></td>
<td><p>::mfp::string::sscanf(2) :</p>
<p>scanf(format_string)，sscanf(input_from, format_string)和fscanf(fd, format_string)和C/C++中的对应函数工作方式相似。scanf读取用户的一行输入，sscanf读取字符串input_from，fscanf从文件（文件号fd）中读取文件内容。字符串format_string支持输入整数（%d、%i、%x等），浮点数（%e、%f等），字符和字符串（%c和%s）等等。用户可以在C语言的帮助文档中找到format_string的构造方法。但是，和C语言有所不同，MFP中的这些函数不需要输入用于存储读取数值的参数。所有的读取的数值将会保存在一个数组中作为返回值返回。比如，sscanf("3Hello world!", "%d%c%c%s")将会返回[3, "H", "e", "llo"]（注意MFP不支持单一字符数据类型，所以单一的字符将会存储为一个只包括一个字符的字符串）。</p>
</td>
</tr>
<tr>
<td><center>start_local_stream</center></td>
<td><p>::mfp::multimedia::webrtc_lib::start_local_stream(2) :</p>
<p>此函数开启web RTC本地视频。注意此处的web RTC是指的用于支持声音和视频通信的web RTC函数库，而不是用于支持数据通信的WEBRTC协议栈。这个函数有两个参数。第一个参数是一个显示窗口的句柄。该显示窗口的句柄可以从open_screen_display函数调用中返回。第二个是个是RTC视频输出子窗口在显示窗口的RTC视频输出子窗口序列中的索引（第一个视频输出子窗口的索引值为0，第二个子窗口索引的值是1，以此类推）。这个函数如果调用成功，其返回值是True。否则，本函数返回False。</p>
</td>
</tr>
<tr>
<td><center>start_sound</center></td>
<td><p>::mfp::multimedia::audio_lib::start_sound(1) :</p>
<p>start_sound(sound_handle)演奏sound_handle所指向的声音文件。如果该声音文件已经启动，这个函数什么也不做。</p>
</td>
</tr>
<tr>
<td><center>stop_all_sounds</center></td>
<td><p>::mfp::multimedia::audio_lib::stop_all_sounds(0) :</p>
<p>stop_all_sounds()停止所有正在播放的声音。</p>
</td>
</tr>
<tr>
<td><center>stop_local_stream</center></td>
<td><p>::mfp::multimedia::webrtc_lib::stop_local_stream(1) :</p>
<p>此函数关闭web RTC本地视频。注意此处的web RTC是指的用于支持声音和视频通信的web RTC函数库，而不是用于支持数据通信的WEBRTC协议栈。这个函数只有一个参数。该参数是一个显示窗口的句柄。该显示窗口的句柄可以从open_screen_display函数调用中返回。本函数没有返回值。</p>
</td>
</tr>
<tr>
<td><center>stop_sound</center></td>
<td><p>::mfp::multimedia::audio_lib::stop_sound(1) :</p>
<p>stop_sound(sound_handle)停止sound_handle所代表的声音的播放。如果该声音没有播放，这个函数什么也不做。</p>
</td>
</tr>
<tr>
<td><center>strcat</center></td>
<td><p>::mfp::string::strcat(2...) :</p>
<p>strcat(string1, string2...)将字符串参数顺次连接在一起，返回新的连接好的字符串。本函数需要至少两个参数。</p>
</td>
</tr>
<tr>
<td><center>strcmp</center></td>
<td><p>::mfp::string::strcmp(6) :</p>
<p>strcmp(src, dest, src_start, src_end, dest_start, dest_end)比较源字符串src（从src_start到src_end）和目标字符串dest（从dest_start到dest_end）。如果src和dest相等返回0，如果src大于dest返回大于0的值，如果src小于dest返回小于0的值。注意字符串索引从0开始，src_end和dest_end的索引位置为最后一个被选中字符的索引位置加一。另外，最后四个参数可以省略，如果被省略，src_start和dest_start的缺省值为0，src_end和dest_end的缺省值为对应字符串的长度。</p>
</td>
</tr>
<tr>
<td><center>strcpy</center></td>
<td><p>::mfp::string::strcpy(6) :</p>
<p>strcpy(src, dest, src_start, src_end, dest_start, dest_end)返回将源字符串src从src_start到src_end拷贝到目标字符串dest从dest_start到dest_end的新字符串值。注意字符串索引从0开始，src_end和dest_end的索引位置为最后一个被选中字符的索引位置加一。另外，最后四个参数可以省略，如果被省略，src_start和dest_start的缺省值为0，src_end和dest_end的缺省值为对应字符串的长度。</p>
</td>
</tr>
<tr>
<td><center>stricmp</center></td>
<td><p>::mfp::string::stricmp(6) :</p>
<p>stricmp(src, dest, src_start, src_end, dest_start, dest_end)在忽略字母大小写的前提下比较源字符串src（从src_start到src_end）和目标字符串dest（从dest_start到dest_end）。如果src和dest相等返回0，如果src大于dest返回大于0的值，如果src小于dest返回小于0的值。注意字符串索引从0开始，src_end和dest_end的索引位置为最后一个被选中字符的索引位置加一。另外，最后四个参数可以省略，如果被省略，src_start和dest_start的缺省值为0，src_end和dest_end的缺省值为对应字符串的长度。</p>
</td>
</tr>
<tr>
<td><center>strlen</center></td>
<td><p>::mfp::string::strlen(1) :</p>
<p>strlen(x)返回字符串x的长度。</p>
</td>
</tr>
<tr>
<td><center>strsub</center></td>
<td><p>::mfp::string::strsub(2) :</p>
<p>strsub(str, start)返回字符串str的子字符串。该子字符串从字符start开始到str的最后一个字符。注意字符串的第一个字符是0号字符。</p>
<p>::mfp::string::strsub(3) :</p>
<p>strsub(str, start, end)返回字符串str的子字符串。该子字符串从字符start开始到字符end-1。注意字符串的第一个字符是0号字符。</p>
</td>
</tr>
<tr>
<td><center>sum_over</center></td>
<td><p>::mfp::math::stat_stoch::sum_over(3) :</p>
<p>函数sum_over(x, y, z)计算基于字符串的表达式x中的变量取值从整数y逐步变化到整数z的值的总合。y和z必须是字符串的形式，其中，y必须写成一个赋值表达式，比如"a=10"，这里，a是变量名。一个函数的例子为sum_over("x+1", "x=1", "10")。</p>
</td>
</tr>
<tr>
<td><center>suspend_until_cond</center></td>
<td><p>::mfp::paracomp::threading::suspend_until_cond(4) :</p>
<p>此函数将挂起当前线程，直到满足特定条件为止。它有四个参数。第一个参数为变量名称。请注意，变量名不是字符串。第二个参数是布尔值。如果为TRUE，则该函数仅在写入变量的值（不必更改）之后才开始检查条件是否满足。否则，函数将在调用函数时立即检查是否满足条件。此参数是可选的。默认情况下为TRUE。第三个参数是运算符字符串。当前此参数仅支持以下值，即""，"=="，"!="，">"，"<"，">="和"<="。""表示如果变量值被写入（未必是被更改），则满足条件。其他运算符意味着使用运算符比较变量的值。如果比较返回TRUE，则满足条件。此参数也是可选的。默认情况下为""。最后一个参数是要比较的值。这也是一个可选参数。如果运算符为""，此参数没有任何作用。对于其他运算符，默认情况下，此参数的值为变量的当前值。例如，suspend_until_cond(a)等于调用suspend_until_cond(a,TRUE,"")，这意味着挂起当前线程，直到变量a被另一个线程写入。另一个示例是suspend_until_cond(a,FALSE,"!=")，这意味着挂起当前线程，直到变量a的值更改为止。第三个示例是suspend_until_cond(a,TRUE,">=",37)，这意味着挂起当前线程，直到写入变量a（不一定更改a的值），并且写入后的值不小于37。如果写入后的值无法和37进行比较，例如a新的值为"Hello"，则当前线程仍然被阻塞。</p>
</td>
</tr>
<tr>
<td><center>system</center></td>
<td><p>::mfp::system::system(1) :</p>
<p>system(str_array)有一个参数。该参数必须是一个字符串或者是一个字符串数组。如果该参数是一个字符串，system运行该字符串所代表的系统指令并且返回该系统指令的返回值。注意系统指令必须是一个可执行的文件以及它的命令参数。由于这个原因，在Windows平台上，诸如system("dir")无法正确执行是因为dir并非是一个单独的可执行文件，而是cmd.exe的一个内部功能。要执行dir指令，用户需要运行system("cmd /c dir")。如果该参数是一个字符串数组，那么该数组的每一个元素是一个将为system函数运行的系统指令的一部分。比如，在Linux平台上，用户想要把文件file1重命名为file2需要运行系统指令"sh -c mv file1 file2"，注意由于我们不是在shell中，这里的"sh -c"是不可以省略的。这时，如果要调用system函数执行上述命令，正确的写法是system(["sh", "-c", "mv file1 file2"])，原因是"mv file1 file2"是sh的一个内部指令，它不能够被分割为几个部分。还要注意，在现阶段，这个函数只能将系统指令的输出打印出来，还无法接受在运行中用户对于该系统指令的输入。此外，如果该系统指令不存在，则会抛出异常。</p>
</td>
</tr>
<tr>
<td><center>tan</center></td>
<td><p>::mfp::math::trigon::tan(1) :</p>
<p>tan(x)返回x的正切值，注意x可以为复数。</p>
</td>
</tr>
<tr>
<td><center>to_lowercase_string</center></td>
<td><p>::mfp::string::to_lowercase_string(1) :</p>
<p>to_lowercase_string(x)返回数据x的打印值（所有的字母均为小写）。</p>
</td>
</tr>
<tr>
<td><center>to_string</center></td>
<td><p>::mfp::string::to_string(1) :</p>
<p>to_string(x)返回数据x的打印值。</p>
</td>
</tr>
<tr>
<td><center>to_uppercase_string</center></td>
<td><p>::mfp::string::to_uppercase_string(1) :</p>
<p>to_uppercase_string(x)返回数据x的打印值（所有的字母均为大写）。</p>
</td>
</tr>
<tr>
<td><center>tostring</center></td>
<td><p>::mfp::string::tostring(1) :</p>
<p>tostring(x) 返回数据x的打印值。</p>
</td>
</tr>
<tr>
<td><center>trim</center></td>
<td><p>::mfp::string::trim(1) :</p>
<p>trim(string)，trim_left(string)和trim_right(string)从字符串的两边或者一边删除任何一个ASCI值小于等于空白字符（' '）的字符。具体说来，trim从左右两边删除任何一个ASCI值小于等于空白字符（' '）的字符，直到左边和右边都遇到了一个ASCI值大于空白字符（' '）的字符；trim_left从左边删除任何一个ASCI值小于等于空白字符（' '）的字符，直到遇到了一个ASCI值大于空白字符（' '）的字符；trim_right从右边删除任何一个ASCI值小于等于空白字符（' '）的字符，直到遇到了一个ASCI值大于空白字符（' '）的字符。例子包括trim(" \n hello world ") （返回"hello world"）, trim_left(" \n hello world "）, （返回"hello world "）以及trim_right(" \n hello world ") （返回" hello world")。</p>
</td>
</tr>
<tr>
<td><center>trim_left</center></td>
<td><p>::mfp::string::trim_left(1) :</p>
<p>trim(string)，trim_left(string)和trim_right(string)从字符串的两边或者一边删除任何一个ASCI值小于等于空白字符（' '）的字符。具体说来，trim从左右两边删除任何一个ASCI值小于等于空白字符（' '）的字符，直到左边和右边都遇到了一个ASCI值大于空白字符（' '）的字符；trim_left从左边删除任何一个ASCI值小于等于空白字符（' '）的字符，直到遇到了一个ASCI值大于空白字符（' '）的字符；trim_right从右边删除任何一个ASCI值小于等于空白字符（' '）的字符，直到遇到了一个ASCI值大于空白字符（' '）的字符。例子包括trim(" \n hello world ") （返回"hello world"）, trim_left(" \n hello world "）, （返回"hello world "）以及trim_right(" \n hello world ") （返回" hello world")。</p>
</td>
</tr>
<tr>
<td><center>trim_right</center></td>
<td><p>::mfp::string::trim_right(1) :</p>
<p>trim(string)，trim_left(string)和trim_right(string)从字符串的两边或者一边删除任何一个ASCI值小于等于空白字符（' '）的字符。具体说来，trim从左右两边删除任何一个ASCI值小于等于空白字符（' '）的字符，直到左边和右边都遇到了一个ASCI值大于空白字符（' '）的字符；trim_left从左边删除任何一个ASCI值小于等于空白字符（' '）的字符，直到遇到了一个ASCI值大于空白字符（' '）的字符；trim_right从右边删除任何一个ASCI值小于等于空白字符（' '）的字符，直到遇到了一个ASCI值大于空白字符（' '）的字符。例子包括trim(" \n hello world ") （返回"hello world"）, trim_left(" \n hello world "）, （返回"hello world "）以及trim_right(" \n hello world ") （返回" hello world")。</p>
</td>
</tr>
<tr>
<td><center>unlink_video_stream</center></td>
<td><p>::mfp::multimedia::webrtc_lib::unlink_video_stream(2...) :</p>
<p>此函数断开视频流向RTC视频输出子窗口的输出。这个函数有两种工作模式。第一种工作模式有3个参数分别为一个显示窗口的句柄（该显示窗口的句柄可以从open_screen_display函数调用中返回）；一个peer connection对象的id；以及一个视频轨的id。第二种工作模式有两个参数分别为一个显示窗口的句柄和一个RTC视频输出子窗口在显示窗口的RTC视频输出子窗口序列中的索引（第一个视频输出子窗口的索引值为0，第二个子窗口索引的值是1，以此类推）。这个函数返回断开的视频轨的数目。</p>
</td>
</tr>
<tr>
<td><center>update_display</center></td>
<td><p>::mfp::graph_lib::display::update_display(1) :</p>
<p>update_display(display)函数刷新一个display。该display既可以是screen display，也可以是image display。</p>
</td>
</tr>
<tr>
<td><center>upper_triangular_matrix</center></td>
<td><p>::mfp::math::matrix::upper_triangular_matrix(1) :</p>
<p>upper_triangular_matrix(x)返回二维方阵x在LU分解之后的上三角矩阵。</p>
</td>
</tr>
<tr>
<td><center>zeros</center></td>
<td><p>::mfp::math::matrix::zeros(1...) :</p>
<p>zeros函数返回一个所有元素都是0的矩阵，本函数的参数用于决定矩阵的尺寸，要么为一批正整数，要么为一个正整数数列。注意函数表达式zeros([])返回常数值0。</p>
</td>
</tr>
</table>
</body>
</html>
